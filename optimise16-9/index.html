<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Cropper</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2A303C">
    <style>
        :root {
            --primary-color: #4A90E2;
            --background-color: #2A303C;
            --text-color: #F4F4F4;
            --container-bg: #3A4151;
            --border-color: #5A6378;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            overflow: hidden;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
            text-align: center;
        }

        header {
            padding: 1rem;
            background-color: var(--container-bg);
            border-bottom: 1px solid var(--border-color);
        }

        main {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            overflow: auto;
        }

        .screen {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
        }

        .screen.active {
            display: flex;
        }

        #upload-screen p {
            max-width: 400px;
            line-height: 1.5;
        }

        .btn {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            background-color: var(--primary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .btn:hover, .btn:focus {
            background-color: #357ABD;
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .btn.btn-secondary {
            background-color: var(--border-color);
        }
        .btn.btn-secondary:hover, .btn.btn-secondary:focus {
            background-color: #4B5263;
            outline-color: var(--border-color);
        }

        #editor-screen {
            gap: 1rem;
        }

        #image-container {
            position: relative;
            max-width: 100%;
            max-height: calc(100% - 80px); /* Account for controls height */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }

        #source-image {
            max-width: 100%;
            max-height: 100%;
            user-select: none;
            pointer-events: none;
        }

        #crop-box-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #crop-box {
            position: absolute;
            border: 2px solid var(--primary-color);
            cursor: move;
            background-color: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
        }

        .crosshair-h, .crosshair-v {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }

        .crosshair-h {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            margin-top: -0.5px;
        }

        .crosshair-v {
            left: 50%;
            top: 0;
            width: 1px;
            height: 100%;
            margin-left: -0.5px;
        }

        #crop-box:focus {
            outline: 2px dashed white;
            outline-offset: 2px;
        }

        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: var(--primary-color);
            border: 2px solid white;
            border-radius: 50%;
        }

        .crop-handle[data-handle="top-left"] { top: -8px; left: -8px; cursor: nwse-resize; }
        .crop-handle[data-handle="top-right"] { top: -8px; right: -8px; cursor: nesw-resize; }
        .crop-handle[data-handle="bottom-left"] { bottom: -8px; left: -8px; cursor: nesw-resize; }
        .crop-handle[data-handle="bottom-right"] { bottom: -8px; right: -8px; cursor: nwse-resize; }

        #controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        #dimensions-display {
            font-size: 0.9rem;
            color: #ccc;
            background-color: var(--container-bg);
            padding: 8px 16px;
            border-radius: 6px;
            min-width: 160px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="app">
        <header>
            <h1>Recadreur d'Image 9:16</h1>
        </header>
        <main>
            <div id="upload-screen" class="screen active">
                <p>Sélectionnez une photo depuis votre appareil pour la recadrer au format portrait (9:16).</p>
                <button id="select-image-btn" class="btn">Sélectionner une Photo</button>
                <input type="file" id="image-input" accept="image/*" hidden>
            </div>
            <div id="editor-screen" class="screen">
                <div id="image-container">
                    <img id="source-image" src="" alt="Source">
                    <div id="crop-box-container">
                        <div id="crop-box" tabindex="0" aria-label="Zone de recadrage. Utilisez les flèches pour déplacer.">
                            <div class="crosshair-h"></div>
                            <div class="crosshair-v"></div>
                            <div class="crop-handle" data-handle="top-left"></div>
                            <div class="crop-handle" data-handle="top-right"></div>
                            <div class="crop-handle" data-handle="bottom-left"></div>
                            <div class="crop-handle" data-handle="bottom-right"></div>
                        </div>
                    </div>
                </div>
                <div id="controls">
                    <div id="dimensions-display">
                        <span id="crop-width">0</span> x <span id="crop-height">0</span> px
                    </div>
                    <button id="save-btn" class="btn">Valider et Sauvegarder</button>
                    <button id="save-resized-btn" class="btn">Valider (1220px)</button>
                    <button id="back-btn" class="btn btn-secondary">Changer d'Image</button>
                </div>
            </div>
        </main>
    </div>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>
    <script>
        /**
         * @license
         * SPDX-License-Identifier: Apache-2.0
        */

        // --- DOM Elements ---
        const uploadScreen = document.getElementById('upload-screen');
        const editorScreen = document.getElementById('editor-screen');
        const selectImageBtn = document.getElementById('select-image-btn');
        const imageInput = document.getElementById('image-input');
        const imageContainer = document.getElementById('image-container');
        const sourceImage = document.getElementById('source-image');
        const cropBox = document.getElementById('crop-box');
        const saveBtn = document.getElementById('save-btn');
        const saveResizedBtn = document.getElementById('save-resized-btn');
        const backBtn = document.getElementById('back-btn');
        const cropWidthSpan = document.getElementById('crop-width');
        const cropHeightSpan = document.getElementById('crop-height');

        // --- State ---
        let state = {
            isDragging: false,
            isResizing: false,
            startX: 0,
            startY: 0,
            startLeft: 0,
            startTop: 0,
            startWidth: 0,
            startHeight: 0,
            handle: null,
            originalFileName: null,
            originalFileType: null,
        };

        const ASPECT_RATIO = 9 / 16;
        let originalImage = null;

        // --- Functions ---

        function showScreen(screen) {
            uploadScreen.classList.toggle('active', screen === 'upload');
            editorScreen.classList.toggle('active', screen === 'editor');
        }

        function updateCropDimensions() {
            if (!originalImage) return;

            const displayImgRect = sourceImage.getBoundingClientRect();
            if (displayImgRect.width === 0 || displayImgRect.height === 0) return;

            const scaleX = originalImage.naturalWidth / displayImgRect.width;
            
            const cropPixelWidth = Math.round(cropBox.offsetWidth * scaleX);
            const cropPixelHeight = Math.round(cropBox.offsetHeight * scaleX);

            cropWidthSpan.textContent = `${cropPixelWidth}`;
            cropHeightSpan.textContent = `${cropPixelHeight}`;
        }

        function initializeCropBox() {
            const containerRect = imageContainer.getBoundingClientRect();
            const imageRect = sourceImage.getBoundingClientRect();
            
            const imageTopInContainer = (containerRect.height - imageRect.height) / 2;
            const imageLeftInContainer = (containerRect.width - imageRect.width) / 2;

            const imageAspectRatio = imageRect.width / imageRect.height;

            let width, height;
            if (imageAspectRatio > ASPECT_RATIO) {
                // Limited by height
                height = imageRect.height * 0.8;
                width = height * ASPECT_RATIO;
            } else {
                // Limited by width
                width = imageRect.width * 0.8;
                height = width / ASPECT_RATIO;
            }

            const top = imageTopInContainer + (imageRect.height - height) / 2;
            const left = imageLeftInContainer + (imageRect.width - width) / 2;

            Object.assign(cropBox.style, {
                top: `${top}px`,
                left: `${left}px`,
                width: `${width}px`,
                height: `${height}px`,
            });

            updateCropDimensions();
        }

        function handleImageLoad(event) {
            const file = event.target.files?.[0];
            if (!file) return;

            state.originalFileName = file.name;
            state.originalFileType = file.type;

            const reader = new FileReader();
            reader.onload = e => {
                sourceImage.src = e.target?.result;
                sourceImage.onload = () => {
                    originalImage = new Image();
                    originalImage.src = sourceImage.src;
                    originalImage.onload = () => {
                        showScreen('editor');
                        setTimeout(initializeCropBox, 0);
                    }
                };
            };
            reader.readAsDataURL(file);
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function onMouseDown(e) {
            e.preventDefault();
            const target = e.target;

            if (target.classList.contains('crop-handle')) {
                state.isResizing = true;
                state.handle = target.dataset.handle;
            } else if (target === cropBox || target.classList.contains('crosshair-h') || target.classList.contains('crosshair-v')) {
                state.isDragging = true;
            } else {
                return;
            }
            
            const rect = cropBox.getBoundingClientRect();
            const containerRect = imageContainer.getBoundingClientRect();

            state.startX = e.clientX;
            state.startY = e.clientY;
            state.startLeft = rect.left - containerRect.left;
            state.startTop = rect.top - containerRect.top;
            state.startWidth = rect.width;
            state.startHeight = rect.height;

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
        }

        function onMouseMove(e) {
            if (!state.isDragging && !state.isResizing) return;
            
            const dx = e.clientX - state.startX;
            const dy = e.clientY - state.startY;
            const imageRect = sourceImage.getBoundingClientRect();
            const containerRect = imageContainer.getBoundingClientRect();
            const imageLeftInContainer = imageRect.left - containerRect.left;
            const imageTopInContainer = imageRect.top - containerRect.top;

            if (state.isDragging) {
                let newLeft = state.startLeft + dx;
                let newTop = state.startTop + dy;
                
                newLeft = clamp(newLeft, imageLeftInContainer, imageLeftInContainer + imageRect.width - cropBox.offsetWidth);
                newTop = clamp(newTop, imageTopInContainer, imageTopInContainer + imageRect.height - cropBox.offsetHeight);
                
                cropBox.style.left = `${newLeft}px`;
                cropBox.style.top = `${newTop}px`;
            } else if (state.isResizing) {
                let { newLeft, newTop, newWidth, newHeight } = calculateNewDimensions(dx, dy);

                // Boundary checks
                if (newLeft < imageLeftInContainer) {
                    newWidth -= (imageLeftInContainer - newLeft);
                    newLeft = imageLeftInContainer;
                    newHeight = newWidth / ASPECT_RATIO;
                }
                if (newTop < imageTopInContainer) {
                    newHeight -= (imageTopInContainer - newTop);
                    newTop = imageTopInContainer;
                    newWidth = newHeight * ASPECT_RATIO;
                }
                if (newLeft + newWidth > imageLeftInContainer + imageRect.width) {
                    newWidth = imageLeftInContainer + imageRect.width - newLeft;
                    newHeight = newWidth / ASPECT_RATIO;
                }
                if (newTop + newHeight > imageTopInContainer + imageRect.height) {
                    newHeight = imageTopInContainer + imageRect.height - newTop;
                    newWidth = newHeight * ASPECT_RATIO;
                }

                const minSize = 20;
                if (newWidth > minSize && newHeight > minSize) {
                    cropBox.style.left = `${newLeft}px`;
                    cropBox.style.top = `${newTop}px`;
                    cropBox.style.width = `${newWidth}px`;
                    cropBox.style.height = `${newHeight}px`;
                    updateCropDimensions();
                }
            }
        }

        function calculateNewDimensions(dx, dy) {
            let { startLeft, startTop, startWidth, startHeight, handle } = state;
            let newWidth = startWidth;
            let newHeight = startHeight;
            let newLeft = startLeft;
            let newTop = startTop;

            switch (handle) {
                case 'top-left':
                    newWidth = startWidth - dx;
                    newHeight = newWidth / ASPECT_RATIO;
                    newLeft = startLeft + dx;
                    newTop = startTop + (startHeight - newHeight);
                    break;
                case 'top-right':
                    newWidth = startWidth + dx;
                    newHeight = newWidth / ASPECT_RATIO;
                    newTop = startTop + (startHeight - newHeight);
                    break;
                case 'bottom-left':
                    newWidth = startWidth - dx;
                    newHeight = newWidth / ASPECT_RATIO;
                    newLeft = startLeft + dx;
                    break;
                case 'bottom-right':
                    newWidth = startWidth + dx;
                    newHeight = newWidth / ASPECT_RATIO;
                    break;
            }
            return { newLeft, newTop, newWidth, newHeight };
        }

        function onMouseUp() {
            state.isDragging = false;
            state.isResizing = false;
            state.handle = null;
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('mouseup', onMouseUp);
        }

        function onKeyDown(e) {
            if (document.activeElement !== cropBox) return;

            const step = e.shiftKey ? 10 : 1;
            let currentLeft = parseFloat(cropBox.style.left);
            let currentTop = parseFloat(cropBox.style.top);

            switch(e.key) {
                case 'ArrowUp': currentTop -= step; break;
                case 'ArrowDown': currentTop += step; break;
                case 'ArrowLeft': currentLeft -= step; break;
                case 'ArrowRight': currentLeft += step; break;
                default: return;
            }
            e.preventDefault();

            const imageRect = sourceImage.getBoundingClientRect();
            const containerRect = imageContainer.getBoundingClientRect();
            const imageLeftInContainer = imageRect.left - containerRect.left;
            const imageTopInContainer = imageRect.top - containerRect.top;

            cropBox.style.left = `${clamp(currentLeft, imageLeftInContainer, imageLeftInContainer + imageRect.width - cropBox.offsetWidth)}px`;
            cropBox.style.top = `${clamp(currentTop, imageTopInContainer, imageTopInContainer + imageRect.height - cropBox.offsetHeight)}px`;
        }


        async function saveCroppedImage(options = {}) {
            if (!originalImage) return;

            const initialCanvas = document.createElement('canvas');
            const ctx = initialCanvas.getContext('2d');
            if (!ctx) return;

            const displayImgRect = sourceImage.getBoundingClientRect();
            const cropBoxRect = cropBox.getBoundingClientRect();

            const scaleX = originalImage.naturalWidth / displayImgRect.width;
            const scaleY = originalImage.naturalHeight / displayImgRect.height;
            
            const sourceX = (cropBoxRect.left - displayImgRect.left) * scaleX;
            const sourceY = (cropBoxRect.top - displayImgRect.top) * scaleY;
            const sourceWidth = cropBoxRect.width * scaleX;
            const sourceHeight = cropBoxRect.height * scaleY;

            initialCanvas.width = sourceWidth;
            initialCanvas.height = sourceHeight;

            ctx.drawImage(
                originalImage,
                sourceX, sourceY, sourceWidth, sourceHeight,
                0, 0, sourceWidth, sourceHeight
            );

            let finalCanvas = initialCanvas;
            const { targetWidth } = options;

            if (targetWidth && sourceWidth > targetWidth) {
                const resizeCanvas = document.createElement('canvas');
                const resizeCtx = resizeCanvas.getContext('2d');
                if (!resizeCtx) return;

                const targetHeight = Math.round(targetWidth / ASPECT_RATIO);
                
                resizeCanvas.width = targetWidth;
                resizeCanvas.height = targetHeight;
                resizeCtx.drawImage(initialCanvas, 0, 0, targetWidth, targetHeight);
                
                finalCanvas = resizeCanvas;
            }

            const fileType = state.originalFileType || 'image/png';
            const quality = fileType === 'image/jpeg' ? 0.85 : undefined;

            finalCanvas.toBlob((blob) => {
                if (!blob) return;
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                const originalName = state.originalFileName || `recadrage-${Date.now()}.png`;
                const lastDotIndex = originalName.lastIndexOf('.');
                const nameWithoutExtension = lastDotIndex !== -1 ? originalName.substring(0, lastDotIndex) : originalName;
                const extension = lastDotIndex !== -1 ? originalName.substring(lastDotIndex) : '';
                const suffix = targetWidth ? `_CROP_${targetWidth}px` : '_CROP';
                
                a.download = `${nameWithoutExtension}${suffix}${extension}`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, fileType, quality);
        }

        // --- Event Listeners ---
        selectImageBtn.addEventListener('click', () => imageInput.click());
        imageInput.addEventListener('change', handleImageLoad);
        cropBox.addEventListener('mousedown', onMouseDown);
        saveBtn.addEventListener('click', () => saveCroppedImage());
        saveResizedBtn.addEventListener('click', () => saveCroppedImage({ targetWidth: 1220 }));
        backBtn.addEventListener('click', () => {
            imageInput.value = '';
            state.originalFileName = null;
            state.originalFileType = null;
            originalImage = null;
            showScreen('upload');
        });
        cropBox.addEventListener('keydown', onKeyDown);

        // --- Init ---
        showScreen('upload');
    </script>
</body>
</html>