/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/

// --- DOM Elements ---
const uploadScreen = document.getElementById('upload-screen') as HTMLDivElement;
const editorScreen = document.getElementById('editor-screen') as HTMLDivElement;
const selectImageBtn = document.getElementById('select-image-btn') as HTMLButtonElement;
const imageInput = document.getElementById('image-input') as HTMLInputElement;
const imageContainer = document.getElementById('image-container') as HTMLDivElement;
const sourceImage = document.getElementById('source-image') as HTMLImageElement;
const cropBoxContainer = document.getElementById('crop-box-container') as HTMLDivElement;
const cropBox = document.getElementById('crop-box') as HTMLDivElement;
const saveBtn = document.getElementById('save-btn') as HTMLButtonElement;
const saveResizedBtn = document.getElementById('save-resized-btn') as HTMLButtonElement;
const backBtn = document.getElementById('back-btn') as HTMLButtonElement;
const cropWidthSpan = document.getElementById('crop-width') as HTMLSpanElement;
const cropHeightSpan = document.getElementById('crop-height') as HTMLSpanElement;

// --- State ---
interface CropState {
    isDragging: boolean;
    isResizing: boolean;
    startX: number;
    startY: number;
    startLeft: number;
    startTop: number;
    startWidth: number;
    startHeight: number;
    handle: string | null;
    originalFileName: string | null;
    originalFileType: string | null;
}

let state: CropState = {
    isDragging: false,
    isResizing: false,
    startX: 0,
    startY: 0,
    startLeft: 0,
    startTop: 0,
    startWidth: 0,
    startHeight: 0,
    handle: null,
    originalFileName: null,
    originalFileType: null,
};

const ASPECT_RATIO = 9 / 16;
let originalImage: HTMLImageElement | null = null;

// --- Functions ---

function showScreen(screen: 'upload' | 'editor') {
    uploadScreen.classList.toggle('active', screen === 'upload');
    editorScreen.classList.toggle('active', screen === 'editor');
}

function updateCropDimensions() {
    if (!originalImage) return;

    const displayImgRect = sourceImage.getBoundingClientRect();
    if (displayImgRect.width === 0 || displayImgRect.height === 0) return;

    const scaleX = originalImage.naturalWidth / displayImgRect.width;
    
    const cropPixelWidth = Math.round(cropBox.offsetWidth * scaleX);
    const cropPixelHeight = Math.round(cropBox.offsetHeight * scaleX);

    cropWidthSpan.textContent = `${cropPixelWidth}`;
    cropHeightSpan.textContent = `${cropPixelHeight}`;
}

function initializeCropBox() {
    const containerRect = imageContainer.getBoundingClientRect();
    const imageRect = sourceImage.getBoundingClientRect();
    
    const imageTopInContainer = (containerRect.height - imageRect.height) / 2;
    const imageLeftInContainer = (containerRect.width - imageRect.width) / 2;

    const imageAspectRatio = imageRect.width / imageRect.height;

    let width, height;
    if (imageAspectRatio > ASPECT_RATIO) {
        height = imageRect.height * 0.8;
        width = height * ASPECT_RATIO;
    } else {
        width = imageRect.width * 0.8;
        height = width / ASPECT_RATIO;
    }

    const top = imageTopInContainer + (imageRect.height - height) / 2;
    const left = imageLeftInContainer + (imageRect.width - width) / 2;

    Object.assign(cropBox.style, {
        top: `${top}px`,
        left: `${left}px`,
        width: `${width}px`,
        height: `${height}px`,
    });

    updateCropDimensions();
}

function handleImageLoad(event: Event) {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (!file) return;

    state.originalFileName = file.name;
    state.originalFileType = file.type;

    const reader = new FileReader();
    reader.onload = e => {
        sourceImage.src = e.target?.result as string;
        sourceImage.onload = () => {
            originalImage = new Image();
            originalImage.src = sourceImage.src;
            originalImage.onload = () => {
                 showScreen('editor');
                 setTimeout(initializeCropBox, 0);
            }
        };
    };
    reader.readAsDataURL(file);
}

function clamp(value: number, min: number, max: number) {
    return Math.max(min, Math.min(max, value));
}

function getEventCoords(e: MouseEvent | TouchEvent): { clientX: number, clientY: number } | null {
    if (e instanceof MouseEvent) {
        return { clientX: e.clientX, clientY: e.clientY };
    }
    if (e.touches && e.touches.length > 0) {
        return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
    }
    return null;
}

function onInteractionStart(e: MouseEvent | TouchEvent) {
    const target = e.target as HTMLElement;

    if (target.classList.contains('crop-handle')) {
        state.isResizing = true;
        state.handle = target.dataset.handle!;
    } else if (target === cropBox || target.classList.contains('crosshair-h') || target.classList.contains('crosshair-v')) {
        state.isDragging = true;
    } else {
        return;
    }
    
    if (e instanceof MouseEvent) {
        e.preventDefault();
    } else {
        e.preventDefault();
    }

    const rect = cropBox.getBoundingClientRect();
    const containerRect = imageContainer.getBoundingClientRect();
    const coords = getEventCoords(e);
    if (!coords) return;

    state.startX = coords.clientX;
    state.startY = coords.clientY;
    state.startLeft = rect.left - containerRect.left;
    state.startTop = rect.top - containerRect.top;
    state.startWidth = rect.width;
    state.startHeight = rect.height;

    window.addEventListener('mousemove', onInteractionMove);
    window.addEventListener('touchmove', onInteractionMove, { passive: false });
    window.addEventListener('mouseup', onInteractionEnd);
    window.addEventListener('touchend', onInteractionEnd);
}

function onInteractionMove(e: MouseEvent | TouchEvent) {
    if (!state.isDragging && !state.isResizing) return;

    if (e instanceof TouchEvent) {
        e.preventDefault();
    }

    const coords = getEventCoords(e);
    if (!coords) return;
    
    const dx = coords.clientX - state.startX;
    const dy = coords.clientY - state.startY;
    const imageRect = sourceImage.getBoundingClientRect();
    const containerRect = imageContainer.getBoundingClientRect();
    const imageLeftInContainer = imageRect.left - containerRect.left;
    const imageTopInContainer = imageRect.top - containerRect.top;

    if (state.isDragging) {
        let newLeft = state.startLeft + dx;
        let newTop = state.startTop + dy;
        
        newLeft = clamp(newLeft, imageLeftInContainer, imageLeftInContainer + imageRect.width - cropBox.offsetWidth);
        newTop = clamp(newTop, imageTopInContainer, imageTopInContainer + imageRect.height - cropBox.offsetHeight);
        
        cropBox.style.left = `${newLeft}px`;
        cropBox.style.top = `${newTop}px`;
    } else if (state.isResizing) {
        let { newLeft, newTop, newWidth, newHeight } = calculateNewDimensions(dx, dy);

        if (newLeft < imageLeftInContainer) {
            newWidth -= (imageLeftInContainer - newLeft);
            newLeft = imageLeftInContainer;
            newHeight = newWidth / ASPECT_RATIO;
        }
        if (newTop < imageTopInContainer) {
            newHeight -= (imageTopInContainer - newTop);
            newTop = imageTopInContainer;
            newWidth = newHeight * ASPECT_RATIO;
        }
        if (newLeft + newWidth > imageLeftInContainer + imageRect.width) {
            newWidth = imageLeftInContainer + imageRect.width - newLeft;
            newHeight = newWidth / ASPECT_RATIO;
        }
        if (newTop + newHeight > imageTopInContainer + imageRect.height) {
            newHeight = imageTopInContainer + imageRect.height - newTop;
            newWidth = newHeight * ASPECT_RATIO;
        }

        const minSize = 20;
        if (newWidth > minSize && newHeight > minSize) {
            cropBox.style.left = `${newLeft}px`;
            cropBox.style.top = `${newTop}px`;
            cropBox.style.width = `${newWidth}px`;
            cropBox.style.height = `${newHeight}px`;
            updateCropDimensions();
        }
    }
}

function calculateNewDimensions(dx: number, dy: number) {
    let { startLeft, startTop, startWidth, startHeight, handle } = state;
    let newWidth = startWidth;
    let newHeight = startHeight;
    let newLeft = startLeft;
    let newTop = startTop;

    switch (handle) {
        case 'top-left':
            newWidth = startWidth - dx;
            newHeight = newWidth / ASPECT_RATIO;
            newLeft = startLeft + dx;
            newTop = startTop + (startHeight - newHeight);
            break;
        case 'top-right':
            newWidth = startWidth + dx;
            newHeight = newWidth / ASPECT_RATIO;
            newTop = startTop + (startHeight - newHeight);
            break;
        case 'bottom-left':
            newWidth = startWidth - dx;
            newHeight = newWidth / ASPECT_RATIO;
            newLeft = startLeft + dx;
            break;
        case 'bottom-right':
            newWidth = startWidth + dx;
            newHeight = newWidth / ASPECT_RATIO;
            break;
    }
    return { newLeft, newTop, newWidth, newHeight };
}

function onInteractionEnd() {
    state.isDragging = false;
    state.isResizing = false;
    state.handle = null;
    window.removeEventListener('mousemove', onInteractionMove);
    window.removeEventListener('touchmove', onInteractionMove);
    window.removeEventListener('mouseup', onInteractionEnd);
    window.removeEventListener('touchend', onInteractionEnd);
}

function onKeyDown(e: KeyboardEvent) {
    if (document.activeElement !== cropBox) return;

    const step = e.shiftKey ? 10 : 1;
    let currentLeft = parseFloat(cropBox.style.left);
    let currentTop = parseFloat(cropBox.style.top);

    switch(e.key) {
        case 'ArrowUp': currentTop -= step; break;
        case 'ArrowDown': currentTop += step; break;
        case 'ArrowLeft': currentLeft -= step; break;
        case 'ArrowRight': currentLeft += step; break;
        default: return;
    }
    e.preventDefault();

    const imageRect = sourceImage.getBoundingClientRect();
    const containerRect = imageContainer.getBoundingClientRect();
    const imageLeftInContainer = imageRect.left - containerRect.left;
    const imageTopInContainer = imageRect.top - containerRect.top;

    cropBox.style.left = `${clamp(currentLeft, imageLeftInContainer, imageLeftInContainer + imageRect.width - cropBox.offsetWidth)}px`;
    cropBox.style.top = `${clamp(currentTop, imageTopInContainer, imageTopInContainer + imageRect.height - cropBox.offsetHeight)}px`;
}


async function saveCroppedImage(options: { targetWidth?: number } = {}) {
    if (!originalImage) return;

    const initialCanvas = document.createElement('canvas');
    const ctx = initialCanvas.getContext('2d');
    if (!ctx) return;

    const displayImgRect = sourceImage.getBoundingClientRect();
    const cropBoxRect = cropBox.getBoundingClientRect();

    const scaleX = originalImage.naturalWidth / displayImgRect.width;
    const scaleY = originalImage.naturalHeight / displayImgRect.height;
    
    const sourceX = (cropBoxRect.left - displayImgRect.left) * scaleX;
    const sourceY = (cropBoxRect.top - displayImgRect.top) * scaleY;
    const sourceWidth = cropBoxRect.width * scaleX;
    const sourceHeight = cropBoxRect.height * scaleY;

    initialCanvas.width = sourceWidth;
    initialCanvas.height = sourceHeight;

    ctx.drawImage(
        originalImage,
        sourceX, sourceY, sourceWidth, sourceHeight,
        0, 0, sourceWidth, sourceHeight
    );

    let finalCanvas = initialCanvas;
    const { targetWidth } = options;

    if (targetWidth && sourceWidth > targetWidth) {
        const resizeCanvas = document.createElement('canvas');
        const resizeCtx = resizeCanvas.getContext('2d');
        if (!resizeCtx) return;

        const targetHeight = Math.round(targetWidth / ASPECT_RATIO);
        
        resizeCanvas.width = targetWidth;
        resizeCanvas.height = targetHeight;
        resizeCtx.drawImage(initialCanvas, 0, 0, targetWidth, targetHeight);
        
        finalCanvas = resizeCanvas;
    }

    const fileType = state.originalFileType || 'image/png';
    const quality = fileType === 'image/jpeg' ? 0.85 : undefined;

    finalCanvas.toBlob((blob) => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;

        const originalName = state.originalFileName || `recadrage-${Date.now()}.png`;
        const lastDotIndex = originalName.lastIndexOf('.');
        const nameWithoutExtension = lastDotIndex !== -1 ? originalName.substring(0, lastDotIndex) : originalName;
        const extension = lastDotIndex !== -1 ? originalName.substring(lastDotIndex) : '';
        const suffix = targetWidth ? `_CROP_${targetWidth}px` : '_CROP';
        
        a.download = `${nameWithoutExtension}${suffix}${extension}`;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, fileType, quality);
}

// --- Event Listeners ---
selectImageBtn.addEventListener('click', () => imageInput.click());
imageInput.addEventListener('change', handleImageLoad);

cropBoxContainer.addEventListener('mousedown', onInteractionStart);
cropBoxContainer.addEventListener('touchstart', onInteractionStart, { passive: false });

saveBtn.addEventListener('click', () => saveCroppedImage());
saveResizedBtn.addEventListener('click', () => saveCroppedImage({ targetWidth: 1220 }));
backBtn.addEventListener('click', () => {
    imageInput.value = '';
    state.originalFileName = null;
    state.originalFileType = null;
    originalImage = null;
    showScreen('upload');
});
cropBox.addEventListener('keydown', onKeyDown);

// --- Init ---
showScreen('upload');