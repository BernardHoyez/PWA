<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RandoEffort - Analyse de parcours</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        header {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 { color: #2c5f2d; font-size: 2em; margin-bottom: 10px; }
        .subtitle { color: #666; font-size: 0.95em; }
        .upload-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        input[type="file"] {
            display: block;
            width: 100%;
            padding: 15px;
            border: 2px dashed #2c5f2d;
            border-radius: 10px;
            cursor: pointer;
            background: #f8f9fa;
            margin-bottom: 15px;
        }
        input[type="file"]:hover { background: #e8f5e9; }
        .map-selector { display: flex; gap: 10px; margin-top: 15px; }
        .map-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        .map-btn.active { background: #2c5f2d; color: white; border-color: #2c5f2d; }
        .map-btn:hover { border-color: #2c5f2d; }
        .content-grid {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }
        #map { height: 600px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .stats-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
        .stat-value { font-size: 1.8em; font-weight: bold; color: #2c5f2d; }
        .ibp-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            display: none;
        }
        .ibp-score { font-size: 3em; font-weight: bold; margin: 10px 0; }
        .ibp-difficulty { font-size: 1.2em; margin-bottom: 10px; }
        .ibp-description { font-size: 0.9em; opacity: 0.9; line-height: 1.5; }
        .legend {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .legend-title { font-weight: bold; margin-bottom: 15px; color: #2c5f2d; }
        .legend-gradient {
            height: 30px;
            background: linear-gradient(to right, #00ff00 0%, #ffff00 20%, #ff9900 40%, #ff0000 60%, #990000 100%);
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .legend-labels { display: flex; justify-content: space-between; font-size: 0.85em; color: #666; }
        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }
        .error-message.active { display: block; }
        .info-message {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            display: none;
            margin-bottom: 15px;
        }
        .progress-bar.active { display: block; }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2c5f2d, #4caf50);
            width: 0%;
            transition: width 0.3s;
        }
        .progress-text {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
            display: none;
        }
        .progress-text.active { display: block; }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(102, 126, 234, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5em;
            z-index: 10000;
        }
        @media (max-width: 968px) {
            .content-grid { grid-template-columns: 1fr; }
            #map { height: 400px; }
        }
    </style>
</head>
<body>
    <div id="loading-screen">Chargement de la cartographie...</div>
    
    <div class="container">
        <header>
            <h1>ü•æ RandoEffort</h1>
            <p class="subtitle">Analysez vos parcours GPX/KML avec altim√©trie IGN et calcul IBP pr√©cis</p>
        </header>

        <div class="upload-section">
            <div class="info-message">
                ‚ú® Les altitudes sont automatiquement enrichies avec les donn√©es IGN pour plus de pr√©cision
            </div>
            <input type="file" id="fileInput" accept=".gpx,.kml" />
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">R√©cup√©ration des altitudes IGN...</div>
            <div class="error-message" id="errorMessage"></div>
            <div class="map-selector">
                <button class="map-btn active" data-layer="osm">OpenStreetMap</button>
                <button class="map-btn" data-layer="ign">IGN Plan V2</button>
            </div>
        </div>

        <div class="content-grid">
            <div><div id="map"></div></div>
            <div>
                <div class="stats-panel">
                    <div class="ibp-card" id="ibpCard">
                        <div class="stat-label">Indice IBP</div>
                        <div class="ibp-score" id="ibpScore">--</div>
                        <div class="ibp-difficulty" id="ibpDifficulty">--</div>
                        <div class="ibp-description" id="ibpDescription">--</div>
                    </div>
                    <div class="stat-card"><div class="stat-label">Distance</div><div class="stat-value" id="distance">-- km</div></div>
                    <div class="stat-card"><div class="stat-label">D√©nivel√© +</div><div class="stat-value" id="elevation">-- m</div></div>
                    <div class="stat-card"><div class="stat-label">Altitude min/max</div><div class="stat-value" id="altitudes">-- / -- m</div></div>
                    <div class="stat-card"><div class="stat-label">Pente moyenne</div><div class="stat-value" id="avgSlope">-- %</div></div>
                    <div class="stat-card"><div class="stat-label">Pente max</div><div class="stat-value" id="maxSlope">-- %</div></div>
                </div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-title">L√©gende des pentes</div>
            <div class="legend-gradient"></div>
            <div class="legend-labels">
                <span>0%</span><span>5%</span><span>10%</span><span>15%</span><span>20%+</span>
            </div>
        </div>
    </div>

    <script>
        (function() {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js';
            script.onload = function() {
                console.log('‚úì Leaflet charg√©');
                document.getElementById('loading-screen').style.display = 'none';
                initApp();
            };
            script.onerror = function() {
                document.getElementById('loading-screen').innerHTML = '‚ùå Erreur de chargement. V√©rifiez votre connexion Internet.';
            };
            document.head.appendChild(script);
        })();

        function initApp() {
            let map, osmLayer, ignLayer, currentRoute = null, currentMarkers = [];

            function initMap() {
                console.log('üó∫Ô∏è Initialisation carte...');
                map = L.map('map').setView([46.5, 2.5], 6);
                
                osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap',
                    maxZoom: 19
                }).addTo(map);
                
                ignLayer = L.tileLayer('https://data.geopf.fr/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2&STYLE=normal&FORMAT=image/png&TILEMATRIXSET=PM&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
                    attribution: '¬© IGN - Plan v2',
                    maxZoom: 19
                });
                
                document.querySelectorAll('.map-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('.map-btn').forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                        if (this.dataset.layer === 'ign') {
                            if (map.hasLayer(osmLayer)) map.removeLayer(osmLayer);
                            if (!map.hasLayer(ignLayer)) ignLayer.addTo(map);
                        } else {
                            if (map.hasLayer(ignLayer)) map.removeLayer(ignLayer);
                            if (!map.hasLayer(osmLayer)) osmLayer.addTo(map);
                        }
                    });
                });
                console.log('‚úì Carte initialis√©e');
            }

            document.getElementById('fileInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.classList.remove('active');
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        if (file.name.toLowerCase().endsWith('.gpx')) {
                            parseGPX(content);
                        } else if (file.name.toLowerCase().endsWith('.kml')) {
                            parseKML(content);
                        }
                    } catch (error) {
                        errorDiv.textContent = 'Erreur: ' + error.message;
                        errorDiv.classList.add('active');
                        console.error(error);
                    }
                };
                reader.readAsText(file);
            });

            function parseGPX(content) {
                console.log('üìÑ Parsing GPX...');
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, 'text/xml');
                const trkpts = xmlDoc.getElementsByTagName('trkpt');
                const rtepts = xmlDoc.getElementsByTagName('rtept');
                const pointsToUse = trkpts.length > 0 ? trkpts : rtepts;
                
                if (pointsToUse.length === 0) throw new Error('Aucun point trouv√©');
                
                const points = [];
                for (let i = 0; i < pointsToUse.length; i++) {
                    const lat = parseFloat(pointsToUse[i].getAttribute('lat'));
                    const lon = parseFloat(pointsToUse[i].getAttribute('lon'));
                    if (!isNaN(lat) && !isNaN(lon)) points.push({ lat, lon, ele: null });
                }
                console.log(`‚úì ${points.length} points extraits`);
                enrichWithIGNElevation(points);
            }

            function parseKML(content) {
                console.log('üìÑ Parsing KML...');
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, 'text/xml');
                const coordinates = xmlDoc.getElementsByTagName('coordinates')[0];
                if (!coordinates) throw new Error('Aucune coordonn√©e trouv√©e');
                
                const coordText = coordinates.textContent.trim();
                const coordLines = coordText.split(/\s+/);
                const points = coordLines.map(line => {
                    const parts = line.trim().split(',');
                    if (parts.length >= 2) {
                        const lon = parseFloat(parts[0]);
                        const lat = parseFloat(parts[1]);
                        return { lat, lon, ele: null };
                    }
                    return null;
                }).filter(p => p && !isNaN(p.lat) && !isNaN(p.lon));
                
                console.log(`‚úì ${points.length} points extraits`);
                enrichWithIGNElevation(points);
            }

            async function enrichWithIGNElevation(points) {
                console.log('üèîÔ∏è Enrichissement avec altitudes IGN...');
                
                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                progressBar.classList.add('active');
                progressText.classList.add('active');
                
                let processedPoints = 0;
                
                // R√©cup√©rer les altitudes point par point
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const url = `https://data.geopf.fr/altimetrie/1.0/calcul/alti/rest/elevation.json?lon=${point.lon}&lat=${point.lat}`;
                    
                    try {
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        if (data.elevations && data.elevations.length > 0) {
                            point.ele = data.elevations[0];
                            console.log(`Point ${i}: lat=${point.lat}, lon=${point.lon}, alt=${point.ele}m`);
                        } else {
                            point.ele = 0;
                            console.warn(`Point ${i}: pas d'altitude`);
                        }
                        
                    } catch (error) {
                        console.warn(`Erreur point ${i}:`, error);
                        point.ele = 0;
                    }
                    
                    processedPoints++;
                    const progress = (processedPoints / points.length) * 100;
                    progressFill.style.width = progress + '%';
                    progressText.textContent = `R√©cup√©ration des altitudes IGN... ${processedPoints}/${points.length} (${Math.round(progress)}%)`;
                    
                    // Petit d√©lai pour ne pas surcharger l'API
                    if (i < points.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                progressBar.classList.remove('active');
                progressText.classList.remove('active');
                
                console.log('‚úì Altitudes IGN r√©cup√©r√©es');
                processPoints(points);
            }

            function processPoints(points) {
                if (points.length < 2) throw new Error('Minimum 2 points requis');
                
                const stats = calculateStats(points);
                const ibp = calculateIBP(stats);
                displayStats(stats, ibp);
                drawRoute(points, stats);
            }

            function calculateStats(points) {
                let distance = 0, elevationGain = 0, minAlt = Infinity, maxAlt = -Infinity;
                let slopes = [], maxSlope = 0;
                
                for (let i = 0; i < points.length; i++) {
                    const alt = points[i].ele || 0;
                    if (alt < minAlt) minAlt = alt;
                    if (alt > maxAlt) maxAlt = alt;
                    
                    if (i > 0) {
                        const prev = points[i - 1];
                        const curr = points[i];
                        const dist = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon);
                        distance += dist;
                        
                        const elevDiff = (curr.ele || 0) - (prev.ele || 0);
                        
                        // Seuil minimal de 1m
                        if (elevDiff > 1) {
                            elevationGain += elevDiff;
                        }
                        
                        if (dist > 0) {
                            const slope = (elevDiff / (dist * 1000)) * 100;
                            slopes.push(slope);
                            if (Math.abs(slope) > maxSlope) maxSlope = Math.abs(slope);
                        }
                    }
                }
                
                const avgSlope = slopes.length > 0 ? slopes.reduce((a, b) => a + b, 0) / slopes.length : 0;
                
                console.log('üìä Stats (altitudes IGN):', {
                    distance_km: distance.toFixed(2),
                    denivele_m: Math.round(elevationGain),
                    alt_min: Math.round(minAlt),
                    alt_max: Math.round(maxAlt),
                    delta_alt: Math.round(maxAlt - minAlt)
                });
                
                return { 
                    distance, 
                    elevationGain, 
                    minAlt: minAlt === Infinity ? 0 : minAlt, 
                    maxAlt: maxAlt === -Infinity ? 0 : maxAlt, 
                    avgSlope, 
                    maxSlope, 
                    points, 
                    slopes 
                };
            }

            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371;
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                          Math.sin(dLon / 2) * Math.sin(dLon / 2);
                return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            }

            function calculateIBP(stats) {
                const D_km = stats.distance;
                const Dplus_m = stats.elevationGain;
                
                const ibp = Math.sqrt(D_km * Dplus_m) * 0.95;
                
                console.log('üéØ Calcul IBP:', {
                    formule: 'sqrt(D_km √ó D+_m) √ó 0.95',
                    distance_km: D_km.toFixed(2),
                    denivele_m: Math.round(Dplus_m),
                    ibp_final: Math.round(ibp)
                });
                
                return Math.max(1, Math.round(ibp));
            }

            function getIBPInfo(ibp) {
                if (ibp < 25) return { level: 'Facile', description: 'Accessible √† tous, id√©ale pour d√©buter.', color: '#4CAF50' };
                if (ibp < 50) return { level: 'Mod√©r√©', description: 'Condition physique correcte requise.', color: '#8BC34A' };
                if (ibp < 75) return { level: 'Difficile', description: 'Bonne condition physique n√©cessaire.', color: '#FF9800' };
                if (ibp < 100) return { level: 'Tr√®s difficile', description: 'Randonneurs exp√©riment√©s uniquement.', color: '#FF5722' };
                return { level: 'Extr√™me', description: 'Excellente condition physique requise.', color: '#F44336' };
            }

            function displayStats(stats, ibp) {
                document.getElementById('distance').textContent = stats.distance.toFixed(2) + ' km';
                document.getElementById('elevation').textContent = Math.round(stats.elevationGain) + ' m';
                document.getElementById('altitudes').textContent = Math.round(stats.minAlt) + ' / ' + Math.round(stats.maxAlt) + ' m';
                document.getElementById('avgSlope').textContent = Math.abs(stats.avgSlope).toFixed(1) + ' %';
                document.getElementById('maxSlope').textContent = stats.maxSlope.toFixed(1) + ' %';
                
                const ibpInfo = getIBPInfo(ibp);
                document.getElementById('ibpScore').textContent = ibp;
                document.getElementById('ibpDifficulty').textContent = ibpInfo.level;
                document.getElementById('ibpDescription').textContent = ibpInfo.description;
                document.getElementById('ibpCard').style.display = 'block';
                document.getElementById('ibpCard').style.background = `linear-gradient(135deg, ${ibpInfo.color} 0%, ${shadeColor(ibpInfo.color, -20)} 100%)`;
            }

            function shadeColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.max(0, Math.min(255, (num >> 16) + amt));
                const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
                const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
                return "#" + ((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1);
            }

            function getSlopeColor(slope) {
                const absSlope = Math.abs(slope);
                if (absSlope < 5) return '#00ff00';
                if (absSlope < 10) return '#ffff00';
                if (absSlope < 15) return '#ff9900';
                if (absSlope < 20) return '#ff0000';
                return '#990000';
            }

            function drawRoute(points, stats) {
                console.log(`üé® Dessin ${points.length} points...`);
                if (currentRoute) map.removeLayer(currentRoute);
                currentMarkers.forEach(m => map.removeLayer(m));
                currentMarkers = [];
                
                const segments = [];
                for (let i = 0; i < points.length - 1; i++) {
                    const slope = stats.slopes[i] || 0;
                    const color = getSlopeColor(slope);
                    segments.push(L.polyline(
                        [[points[i].lat, points[i].lon], [points[i + 1].lat, points[i + 1].lon]],
                        { color, weight: 6, opacity: 0.8 }
                    ));
                }
                
                currentRoute = L.layerGroup(segments).addTo(map);
                
                const startMarker = L.marker([points[0].lat, points[0].lon]).addTo(map).bindPopup('üèÅ D√©part');
                const endMarker = L.marker([points[points.length - 1].lat, points[points.length - 1].lon]).addTo(map).bindPopup('üéØ Arriv√©e');
                currentMarkers.push(startMarker, endMarker);
                
                const bounds = L.latLngBounds(points.map(p => [p.lat, p.lon]));
                map.fitBounds(bounds, { padding: [50, 50] });
                console.log('‚úì Trac√© affich√©');
            }

            initMap();
        }
    </script>
</body>
</html>