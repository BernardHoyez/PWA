
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visite de Site - Editeur</title>

    <meta name="theme-color" content="#3498db"/>
    <link rel="manifest" href="manifest.json">
    
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --background-color: #ecf0f1;
            --surface-color: #ffffff;
            --text-color: #34495e;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        #root {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 1rem;
        }

        header h1 {
            color: var(--secondary-color);
            margin: 0;
        }

        .visit-title-section {
            margin-bottom: 2rem;
            background-color: var(--surface-color);
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .visit-title-section label {
            display: block;
            font-weight: bold;
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .point-counter {
            font-size: 1.1rem;
            font-weight: bold;
        }

        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
        }

        button:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-danger:hover {
            background-color: #c0392b;
        }

        .btn-validate {
            background-color: var(--warning-color);
            color: white;
        }

        .btn-validate:hover {
            background-color: #e67e22;
        }

        .btn-validate:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .btn-export {
            background-color: var(--success-color);
            color: white;
        }

        .btn-export:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .point-card {
            background-color: var(--surface-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-left: 5px solid var(--primary-color);
            transition: border-left-color 0.3s ease-in-out;
        }

        .point-card--valid {
            border-left-color: var(--success-color);
        }
        .point-card--invalid {
            border-left-color: var(--danger-color);
        }

        .point-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .point-header h2 {
            margin: 0;
            color: var(--secondary-color);
        }

        .validation-errors {
            background-color: #fbeae5;
            color: var(--danger-color);
            border: 1px solid var(--danger-color);
            border-radius: 5px;
            padding: 0.5rem 1rem;
            margin-bottom: 1rem;
        }
        .validation-errors p {
            margin: 0.5rem 0;
            font-weight: bold;
        }
        .validation-errors ul {
            margin: 0.5rem 0;
            padding-left: 20px;
        }


        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        input[type="text"],
        textarea,
        input[type="file"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1rem;
            font-family: var(--font-family);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .coords-section {
            background-color: #f8f9f9;
            padding: 1rem;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
        }

        .coords-display {
            font-family: monospace;
            font-size: 1.1rem;
            background: #e9ecef;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            text-align: center;
        }

        .map-container {
            height: 300px;
            width: 100%;
            border-radius: 5px;
            margin-top: 1rem;
        }

        .media-preview {
            margin-top: 1rem;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
        }

        img.media-preview {
            max-width: 100%;
            height: auto;
            max-height: 300px;
            display: block;
            object-fit: cover;
        }

        video.media-preview,
        audio.media-preview {
            width: 100%;
            display: block;
        }

        @media (max-width: 600px) {
            #root {
                padding: 10px;
            }
            .controls {
                flex-direction: column;
                gap: 1rem;
            }
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "leaflet": "https://esm.sh/leaflet@1.9.4",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "react/": "https://aistudiocdn.com/react@^19.1.1/"
  }
}
</script>
</head>
<body>
    <noscript>Vous devez activer JavaScript pour utiliser cette application.</noscript>
    <div id="root"></div>
    <script type="module">
import React, { useState, useEffect, useRef, useMemo } from 'react';
import { createRoot } from 'react-dom/client';
import L from 'leaflet';

const MapComponent = ({ pointId, latitude, longitude, onCoordsChange }) => {
    const mapRef = useRef(null);
    const markerRef = useRef(null);
    const mapContainerRef = useRef(null);

    useEffect(() => {
        if (mapContainerRef.current && !mapRef.current) {
            const initialLat = latitude ?? 48.8566; // Default to Paris
            const initialLng = longitude ?? 2.3522;
            const initialZoom = latitude ? 13 : 5;

            const map = L.map(mapContainerRef.current).setView([initialLat, initialLng], initialZoom);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            const marker = L.marker([initialLat, initialLng], {
                draggable: true,
                autoPan: true
            }).addTo(map);

            marker.on('dragend', (event) => {
                const newCoords = event.target.getLatLng();
                onCoordsChange(newCoords);
            });
            
            mapRef.current = map;
            markerRef.current = marker;
        }

        return () => {
             if (mapRef.current) {
                mapRef.current.remove();
                mapRef.current = null;
            }
        };
    }, [pointId]);

     useEffect(() => {
        if (mapRef.current && markerRef.current && latitude !== null && longitude !== null) {
            const currentMarkerPos = markerRef.current.getLatLng();
            if (currentMarkerPos.lat !== latitude || currentMarkerPos.lng !== longitude) {
                 const newLatLng = L.latLng(latitude, longitude);
                 mapRef.current.setView(newLatLng, mapRef.current.getZoom());
                 markerRef.current.setLatLng(newLatLng);
            }
        }
    }, [latitude, longitude]);


    return React.createElement('div', { ref: mapContainerRef, id: `map-${pointId}`, className: "map-container" });
};

const toDecimal = (gpsData, ref) => {
    if (!gpsData || gpsData.length !== 3) return 0;
    let decimal = gpsData[0] + gpsData[1] / 60 + gpsData[2] / 3600;
    if (ref === 'S' || ref === 'W') {
        decimal = -decimal;
    }
    return decimal;
};

const formatCoords = (lat, lon) => {
    if (lat === null || lon === null) {
        return "Positionnez le marqueur sur la carte";
    }
    const latDirection = lat >= 0 ? 'N' : 'S';
    const lonDirection = lon >= 0 ? 'E' : 'W';
    return `${Math.abs(lat).toFixed(5)}${latDirection}, ${Math.abs(lon).toFixed(5)}${lonDirection}`;
};


const Point = ({ point, onDelete, onUpdate, isValid }) => {
    const [imagePreviewUrl, setImagePreviewUrl] = useState(null);
    const [videoPreviewUrl, setVideoPreviewUrl] = useState(null);
    const [audioPreviewUrl, setAudioPreviewUrl] = useState(null);

    useEffect(() => {
        const createUrl = (mediaFile) => {
            if (!mediaFile || !mediaFile.buffer) return null;
            const blob = new Blob([mediaFile.buffer], { type: mediaFile.type });
            return URL.createObjectURL(blob);
        };

        const newImageUrl = createUrl(point.image);
        const newVideoUrl = createUrl(point.video);
        const newAudioUrl = createUrl(point.audio);

        setImagePreviewUrl(newImageUrl);
        setVideoPreviewUrl(newVideoUrl);
        setAudioPreviewUrl(newAudioUrl);

        return () => {
            if (newImageUrl) URL.revokeObjectURL(newImageUrl);
            if (newVideoUrl) URL.revokeObjectURL(newVideoUrl);
            if (newAudioUrl) URL.revokeObjectURL(newAudioUrl);
        };
    }, [point.image, point.video, point.audio]);

    const handleFileChange = async (e, mediaType, allowedType, alertType) => {
        const file = e.target.files?.[0];
        const input = e.target;
        
        if (!file) {
            onUpdate(point.id, { [mediaType]: null });
            return;
        }

        if (file.type !== allowedType) {
            alert(`Le fichier doit être au format ${alertType}.`);
            input.value = '';
            onUpdate(point.id, { [mediaType]: null });
            return;
        }
        if (file.size > 20 * 1024 * 1024) {
            alert(`Le fichier ne doit pas dépasser 20 Mo.`);
            input.value = '';
            onUpdate(point.id, { [mediaType]: null });
            return;
        }

        try {
            const buffer = await file.arrayBuffer();
            
            onUpdate(point.id, { [mediaType]: { name: file.name, type: file.type, buffer } });

            if (mediaType === 'image') {
                const blob = new Blob([buffer], { type: file.type });
                const tempUrl = URL.createObjectURL(blob);
                const img = document.createElement('img');

                img.onload = () => {
                    EXIF.getData(img, function() {
                        const lat = EXIF.getTag(this, "GPSLatitude");
                        const lon = EXIF.getTag(this, "GPSLongitude");
                        const latRef = EXIF.getTag(this, "GPSLatitudeRef");
                        const lonRef = EXIF.getTag(this, "GPSLongitudeRef");

                        if (lat && lon && latRef && lonRef) {
                            const latitude = toDecimal(lat, latRef);
                            const longitude = toDecimal(lon, lonRef);
                            onUpdate(point.id, { latitude, longitude });
                        } else {
                            alert("Aucune donnée GPS trouvée dans l'image. Veuillez positionner le point manuellement sur la carte.");
                        }
                        URL.revokeObjectURL(tempUrl);
                    });
                };

                img.onerror = () => {
                    alert("Erreur lors de la lecture de l'image pour l'analyse GPS.");
                    URL.revokeObjectURL(tempUrl);
                };
                
                img.src = tempUrl;
            }
        } catch (error) {
            console.error(`Erreur de lecture du fichier ${mediaType}:`, error);
            alert(`Impossible de lire le fichier ${alertType}.`);
            input.value = '';
            onUpdate(point.id, { [mediaType]: null });
        }
    };
    
    const handleCoordsChange = (newCoords) => {
        onUpdate(point.id, { latitude: newCoords.lat, longitude: newCoords.lng });
    };

    return React.createElement('div', { className: `point-card ${isValid ? 'point-card--valid' : 'point-card--invalid'}`, 'aria-labelledby': `point-title-${point.id}` },
        React.createElement('div', { className: "point-header" },
            React.createElement('h2', { id: `point-title-${point.id}` }, `Point #${point.id}`),
            React.createElement('button', { className: "btn-danger", onClick: () => onDelete(point.id), 'aria-label': `Supprimer le point ${point.id}` }, 'Supprimer')
        ),
        !isValid && React.createElement('div', { className: "validation-errors" },
            React.createElement('p', null, 'Champs obligatoires manquants :'),
            React.createElement('ul', null,
                point.title.trim() === '' && React.createElement('li', null, 'Titre du point'),
                (point.latitude === null || point.longitude === null) && React.createElement('li', null, 'Coordonnées GPS')
            )
        ),
        React.createElement('div', { className: "form-group" },
            React.createElement('label', { htmlFor: `title-${point.id}` }, 'Titre du point (1-30 caractères)'),
            React.createElement('input', { type: "text", id: `title-${point.id}`, value: point.title, onChange: (e) => onUpdate(point.id, { title: e.target.value }), maxLength: 30, required: true })
        ),
        React.createElement('div', { className: "form-group" },
            React.createElement('label', { htmlFor: `image-${point.id}` }, 'Image (JPEG, max 20Mo)'),
            React.createElement('input', { type: "file", id: `image-${point.id}`, accept: "image/jpeg", onChange: (e) => handleFileChange(e, 'image', 'image/jpeg', 'JPEG') }),
            imagePreviewUrl && React.createElement('img', { src: imagePreviewUrl, alt: "Aperçu de l'image", className: "media-preview" })
        ),
        React.createElement('div', { className: "coords-section" },
            React.createElement('div', { className: "form-group" },
                React.createElement('label', null, 'Coordonnées GPS'),
                React.createElement('div', { className: "coords-display" }, formatCoords(point.latitude, point.longitude)),
                React.createElement(MapComponent, { pointId: point.id, latitude: point.latitude, longitude: point.longitude, onCoordsChange: handleCoordsChange })
            )
        ),
        React.createElement('div', { className: "form-group" },
            React.createElement('label', { htmlFor: `video-${point.id}` }, 'Vidéo (MP4, max 20Mo)'),
            React.createElement('input', { type: "file", id: `video-${point.id}`, accept: "video/mp4", onChange: (e) => handleFileChange(e, 'video', 'video/mp4', 'MP4') }),
            videoPreviewUrl && React.createElement('video', { src: videoPreviewUrl, controls: true, className: "media-preview" })
        ),
        React.createElement('div', { className: "form-group" },
            React.createElement('label', { htmlFor: `audio-${point.id}` }, 'Audio (MP3, max 20Mo)'),
            React.createElement('input', { type: "file", id: `audio-${point.id}`, accept: "audio/mpeg", onChange: (e) => handleFileChange(e, 'audio', 'audio/mpeg', 'MP3') }),
            audioPreviewUrl && React.createElement('audio', { src: audioPreviewUrl, controls: true, preload: "metadata", className: "media-preview" })
        ),
        React.createElement('div', { className: "form-group" },
            React.createElement('label', { htmlFor: `comment-${point.id}` }, 'Commentaire'),
            React.createElement('textarea', { id: `comment-${point.id}`, rows: 4, value: point.comment, onChange: (e) => onUpdate(point.id, { comment: e.target.value }) })
        )
    );
};

const App = () => {
    const [visitTitle, setVisitTitle] = useState('');
    const [points, setPoints] = useState([]);
    const [nextPointId, setNextPointId] = useState(1);
    const [isVisitValidated, setIsVisitValidated] = useState(false);

    const validatePoint = (point) => {
        return point.title.trim() !== '' && point.latitude !== null && point.longitude !== null;
    };

    const isReadyForValidation = useMemo(() => {
        const allPointsValid = points.length > 0 && points.every(validatePoint);
        const titleValid = visitTitle.trim() !== '';
        return allPointsValid && titleValid;
    }, [points, visitTitle]);

    useEffect(() => {
        setIsVisitValidated(false);
    }, [points, visitTitle]);

    const handleValidate = () => {
        if (isReadyForValidation) {
            setIsVisitValidated(true);
            alert("Visite validée ! Vous pouvez maintenant exporter.");
        } else {
            alert("La visite n'est pas prête pour la validation. Vérifiez le titre de la visite et que tous les points sont complets.");
        }
    };

    const addPoint = () => {
        if (points.length >= 99) {
            alert("Vous ne pouvez pas ajouter plus de 99 points.");
            return;
        }
        const newPoint = { 
            id: nextPointId, 
            title: '',
            latitude: null,
            longitude: null,
            image: null,
            video: null,
            audio: null,
            comment: '',
        };
        setPoints([...points, newPoint]);
        setNextPointId(nextPointId + 1);
    };

    const deletePoint = (id) => {
        setPoints(prevPoints => prevPoints.filter(point => point.id !== id));
    };
    
    const updatePoint = (id, updatedData) => {
        setPoints(prevPoints => prevPoints.map(p => p.id === id ? { ...p, ...updatedData } : p));
    };

    const handleExport = async () => {
        if (!isVisitValidated) {
            alert("Veuillez valider la visite avant d'exporter.");
            return;
        }
        try {
            const zip = new JSZip();
            const dataFolder = zip.folder("data");
            if (!dataFolder) throw new Error("Impossible de créer le dossier data.");

            const visitStructure = [];

            for (const point of points) {
                const pointFolder = dataFolder.folder(point.id.toString());
                if (!pointFolder) throw new Error(`Impossible de créer le dossier pour le point ${point.id}.`);
                
                const pointInfo = {
                    id: point.id,
                    folder: point.id.toString(),
                };

                pointFolder.file("Titre.txt", point.title);
                pointInfo.titleFile = "Titre.txt";
                
                pointFolder.file("Localisation.txt", formatCoords(point.latitude, point.longitude));
                pointInfo.locationFile = "Localisation.txt";

                if (point.comment) {
                    pointFolder.file("Commentaire.txt", point.comment);
                    pointInfo.commentFile = "Commentaire.txt";
                }

                if (point.image) {
                    pointFolder.file(point.image.name, point.image.buffer);
                    pointInfo.image = point.image.name;
                }
                if (point.video) {
                    pointFolder.file(point.video.name, point.video.buffer);
                    pointInfo.video = point.video.name;
                }
                if (point.audio) {
                    pointFolder.file(point.audio.name, point.audio.buffer);
                    pointInfo.audio = point.audio.name;
                }

                visitStructure.push(pointInfo);
            }

            zip.file("visit.json", JSON.stringify(visitStructure, null, 2));

            const content = await zip.generateAsync({ type: "blob" });
            
            const link = document.createElement('a');
            const sanitizedTitle = visitTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            link.download = `${sanitizedTitle || 'visite'}.zip`;
            link.href = URL.createObjectURL(content);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);

        } catch (error) {
            console.error("L'export a échoué:", error);
            alert("Une erreur inattendue est survenue lors de la préparation de l'export.");
        }
    };

    return React.createElement(React.Fragment, null,
        React.createElement('header', null,
            React.createElement('h1', null, 'Visite de Site - Editeur')
        ),
        React.createElement('main', null,
            React.createElement('section', { className: "visit-title-section" },
                React.createElement('label', { htmlFor: "visit-title" }, 'Titre de la visite (obligatoire)'),
                React.createElement('input', { type: "text", id: "visit-title", value: visitTitle, onChange: (e) => setVisitTitle(e.target.value), placeholder: "Ex: Tour des châteaux de la Loire", required: true })
            ),
            React.createElement('div', { className: "controls" },
                React.createElement('span', { className: "point-counter" }, `${points.length} / 99 Points`),
                React.createElement('button', { className: "btn-primary", onClick: addPoint }, 'Ajouter un point'),
                !isVisitValidated ? (
                    React.createElement('button', { className: "btn-validate", disabled: !isReadyForValidation, onClick: handleValidate }, 'Valider la visite')
                ) : (
                    React.createElement('button', { className: "btn-export", onClick: handleExport }, 'Exporter (.zip)')
                )
            ),
            React.createElement('div', { className: "points-list" },
                points.map(point => React.createElement(Point, { key: point.id, point: point, onDelete: deletePoint, onUpdate: updatePoint, isValid: validatePoint(point) }))
            )
        )
    );
};

const container = document.getElementById('root');
if (container) {
    const root = createRoot(container);
    root.render(React.createElement(App));
}

    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('SW registered: ', registration);
                }).catch(registrationError => {
                    console.log('SW registration failed: ', registrationError);
                });
            });
        }
    </script>
</body>
</html>
