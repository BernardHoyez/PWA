<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrekTiles ‚Äì G√©n√©rateur PMTiles offline</title>
    <meta name="description" content="Cr√©er des cartes hors-ligne PMTiles (OSM ou IGN) pour randonn√©e, trekking, GPS">
    <meta name="theme-color" content="#2563eb">

    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icon192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon512.png">
    <link rel="apple-touch-icon" href="icon192.png">

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
               background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 15px; }
        .container { max-width: 1200px; margin: 0 auto; background: #fff; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); overflow: hidden; }
        .header { background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%); color: #fff; padding: 30px; text-align: center; }
        .header h1 { font-size: 2.5em; margin-bottom: 8px; }
        .content { padding: 30px; }
        .section { margin-bottom: 30px; padding: 25px; background: #f8fafc; border-radius: 15px; border: 2px solid #e2e8f0; }
        .section h2 { color: #2563eb; margin-bottom: 20px; font-size: 1.5em; display: flex; align-items: center; gap: 10px; }
        .input-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        input, select { width: 100%; padding: 12px 15px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 1em; background: #fff; }
        input:focus, select:focus { outline: none; border-color: #2563eb; box-shadow: 0 0 0 3px rgba(37,99,235,0.1); }
        .btn { padding: 12px 25px; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; transition: all .3s; }
        .btn-primary { background: linear-gradient(135deg, #2563eb, #3b82f6); color: #fff; box-shadow: 0 4px 15px rgba(37,99,235,0.3); }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-success { background: #10b981; color: #fff; }
        #map { width: 100%; height: 420px; border-radius: 15px; margin-top: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); }
        .slider-value { background: #2563eb; color: #fff; padding: 5px 15px; border-radius: 20px; font-weight: 600; margin-left: 10px; }
        .progress-container { display: none; margin-top: 25px; padding: 20px; background: #fff; border-radius: 12px; border: 2px solid #2563eb; }
        .progress-bar { height: 32px; background: #e2e8f0; border-radius: 16px; overflow: hidden; margin-bottom: 12px; }
        .progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #2563eb, #3b82f6); transition: width .4s; color: #fff; font-weight: 600; display: flex; align-items: center; justify-content: center; }
        .folder-section { background: #fef3c7; border: 2px solid #f59e0b; padding: 20px; border-radius: 15px; margin: 25px 0; }
        @media (max-width: 768px) { .input-row { grid-template-columns: 1fr; } #map { height: 300px; } .header h1 { font-size: 1.9em; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è TrekTiles</h1>
            <p>G√©n√©rateur de cartes hors-ligne PMTiles (OSM ‚Ä¢ IGN)</p>
        </div>

        <div class="content">
            <div class="section">
                <h2>üó∫Ô∏è Source des tuiles</h2>
                <div class="input-group">
                    <label>Choisir le fond de carte</label>
                    <select id="tileSource" onchange="changeTileSource()">
                        <option value="osm">OpenStreetMap</option>
                        <option value="ign">IGN Plan v2 (France)</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <h2>üìç Position du centre</h2>
                <div class="input-row">
                    <input type="number" id="lat" step="0.000001" value="44.8378" placeholder="Latitude">
                    <input type="number" id="lon" step="0.000001" value="-0.5792" placeholder="Longitude">
                </div>
                <button class="btn btn-primary" onclick="setCenterManual()" style="margin-top: 10px;">üìå Positionner</button>
                <button class="btn btn-primary" onclick="setCenterGPS()" style="margin-left: 10px;">üì± Ma position GPS</button>
                <p style="margin-top: 10px; color: #64748b; font-size: 0.9em;">Ou cliquez directement sur la carte</p>
                <div id="map"></div>
                <div class="info-box" id="centerInfo" style="background: #dbeafe; padding: 15px; border-radius: 8px; margin-top: 15px;">
                    <p><strong>Centre actuel:</strong> Lat: 44.8378, Lon: -0.5792</p>
                </div>
            </div>

            <div class="section">
                <h2>üéØ Param√®tres de g√©n√©ration</h2>
                <div class="slider-container" style="margin: 20px 0;">
                    <label>Rayon de capture: <span class="slider-value" id="radiusValue">10 km</span></label>
                    <input type="range" id="radius" min="1" max="50" value="10" step="1" oninput="updateRadius()" style="width: 100%; margin-top: 8px;">
                </div>
                <div class="zoom-controls" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                    <div>
                        <label>Zoom minimum</label>
                        <input type="number" id="minZoom" value="10" min="0" max="18">
                    </div>
                    <div>
                        <label>Zoom maximum</label>
                        <input type="number" id="maxZoom" value="16" min="0" max="18">
                    </div>
                </div>
                <div class="folder-section">
                    <h3>üìÅ Dossier de sauvegarde</h3>
                    <button class="btn btn-success" onclick="selectDirectory()" id="dirBtn" style="width: 100%; margin-bottom: 15px; padding: 15px; font-size: 1.1em;">
                        Activer le choix du dossier
                    </button>
                    <div class="info-box" id="dirInfo" style="background: #e0e7ff; border-left: 4px solid #6366f1; padding: 15px; border-radius: 8px;">
                        <p id="dirPath"><strong>Par d√©faut :</strong> T√©l√©chargements<br><br>
                        üí° <strong>Conseil :</strong> Cr√©ez un dossier "cartesPMTiles" dans Documents pour organiser vos cartes.</p>
                    </div>
                </div>
                <button class="btn btn-primary" onclick="generatePMTiles()" style="width: 100%; margin-top: 20px; padding: 15px; font-size: 1.1em;">
                    üöÄ G√©n√©rer le fichier PMTiles
                </button>
                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                    <div class="progress-text" id="progressText" style="text-align: center; color: #334155; font-size: 0.9em; font-weight: 600;">Pr√©paration...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let map;
        let centerMarker;
        let circleLayer;
        let tileLayer;
        let centerLat = 44.8378;
        let centerLon = -0.5792;
        let directoryHandle = null;
        let currentTileSource = 'osm';

        function initMap() {
            map = L.map('map').setView([centerLat, centerLon], 13);
            // Ajout initial de la couche OSM
            tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
            centerMarker = L.marker([centerLat, centerLon]).addTo(map);
            circleLayer = L.circle([centerLat, centerLon], {
                radius: 10000,
                color: '#2563eb',
                fillColor: '#3b82f6',
                fillOpacity: 0.2
            }).addTo(map);
            map.on('click', function(e) {
                centerLat = e.latlng.lat;
                centerLon = e.latlng.lng;
                updateCenter();
            });
            updateCenter();
        }

        function changeTileSource() {
            currentTileSource = document.getElementById('tileSource').value;
            map.removeLayer(tileLayer);
            if (currentTileSource === 'osm') {
                tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(map);
            } else if (currentTileSource === 'ign') {
                tileLayer = L.tileLayer('https://data.geopf.fr/wmts?' +
                    'SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0' +
                    '&LAYER=GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2&STYLE=normal&FORMAT=image/png' +
                    '&TILEMATRIXSET=PM&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}', {
                    attribution: '¬© IGN - Plan v2',
                    maxZoom: 19,
                    minZoom: 0
                }).addTo(map);
            }
        }

        function updateCenter() {
            centerMarker.setLatLng([centerLat, centerLon]);
            circleLayer.setLatLng([centerLat, centerLon]);
            map.setView([centerLat, centerLon]);
            document.getElementById('lat').value = centerLat.toFixed(6);
            document.getElementById('lon').value = centerLon.toFixed(6);
            document.getElementById('centerInfo').innerHTML = `<p><strong>Centre actuel:</strong> Lat: ${centerLat.toFixed(6)}, Lon: ${centerLon.toFixed(6)}</p>`;
            updateRadius();
        }

        function setCenterManual() {
            centerLat = parseFloat(document.getElementById('lat').value);
            centerLon = parseFloat(document.getElementById('lon').value);
            updateCenter();
        }

        function setCenterGPS() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    centerLat = position.coords.latitude;
                    centerLon = position.coords.longitude;
                    updateCenter();
                }, function(error) {
                    alert('Erreur de g√©olocalisation: ' + error.message);
                });
            } else {
                alert('G√©olocalisation non support√©e.');
            }
        }

        function updateRadius() {
            const radius = parseFloat(document.getElementById('radius').value);
            document.getElementById('radiusValue').textContent = radius + ' km';
            circleLayer.setRadius(radius * 1000);
        }

        function selectDirectory() {
            directoryHandle = 'use_picker';
            const btn = document.getElementById('dirBtn');
            btn.textContent = '‚úÖ Mode activ√© !';
            btn.className = 'btn btn-success';
            document.getElementById('dirPath').innerHTML = '<strong>‚úÖ Mode activ√© !</strong><br>Lors de la g√©n√©ration, choisissez votre dossier (ex: Documents/cartesPMTiles).';
            document.getElementById('dirInfo').style.background = '#d1fae5';
            document.getElementById('dirInfo').style.borderLeftColor = '#10b981';
        }

        // Calcul des bounds des tuiles
        function getTileBounds(lat, lon, radiusKm, zoom) {
            const R = 6371;
            const latRad = lat * Math.PI / 180;
            const latOffset = (radiusKm / R) * (180 / Math.PI);
            const lonOffset = (radiusKm / R) * (180 / Math.PI) / Math.cos(latRad);
            const minLat = lat - latOffset;
            const maxLat = lat + latOffset;
            const minLon = lon - lonOffset;
            const maxLon = lon + lonOffset;

            function long2tile(lon, z) { return Math.floor((lon + 180) / 360 * Math.pow(2, z)); }
            function lat2tile(lat, z) { 
                return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, z)); 
            }

            return {
                minX: long2tile(minLon, zoom),
                maxX: long2tile(maxLon, zoom),
                minY: lat2tile(maxLat, zoom),
                maxY: lat2tile(minLat, zoom)
            };
        }

        // Impl√©mentation simple d'un PMTiles writer (header + directory + data)
        class SimplePMTilesWriter {
            constructor() {
                this.tiles = []; // {z, x, y, data: Uint8Array, length: number}
                this.metadata = {};
            }

            setMetadata(key, value) { this.metadata[key] = value; }

            addTile(z, x, y, data) {
                this.tiles.push({ z, x, y, data: new Uint8Array(data), length: data.byteLength });
            }

            async finish() {
                // Trier les tuiles par z/x/y pour l'ordre lexicographique
                this.tiles.sort((a, b) => a.z - b.z || a.x - b.x || a.y - b.y);

                // Calculer les positions (offsets)
                let offset = 128; // Taille header fixe
                const entries = [];
                for (let tile of this.tiles) {
                    entries.push({ address: offset >>> 0, length: tile.length >>> 0 }); // Little-endian uint32/64
                    offset += tile.length;
                }

                // Header PMTiles v1.0 (128 bytes)
                const header = new ArrayBuffer(128);
                const view = new DataView(header);
                let pos = 0;
                // Magic bytes
                const magic = new Uint8Array([137, 80, 77, 84, 76, 69, 83, 10]); // \x89PMTILES\n
                for (let i = 0; i < 8; i++) view.setUint8(pos++, magic[i]);
                // Version 1.0
                view.setUint32(pos, 1, true); pos += 4; // Little-endian
                view.setUint32(pos, 0, true); pos += 4; // Tile format (0 = raw)
                // Min/max zoom
                view.setUint8(pos++, this.tiles.length > 0 ? Math.min(...this.tiles.map(t => t.z)) : 0);
                view.setUint8(pos++, this.tiles.length > 0 ? Math.max(...this.tiles.map(t => t.z)) : 0);
                // 14 bytes reserved (0)
                pos += 14;
                // Num tiles (uint64 LE)
                view.setUint32(pos, this.tiles.length, true); pos += 4;
                view.setUint32(pos, 0, true); pos += 4; // High 32 bits
                // Num entries (m√™me que num tiles)
                view.setUint32(pos, this.tiles.length, true); pos += 4;
                view.setUint32(pos, 0, true); pos += 4;
                // Metadata root (simplifi√© : 0 pour pas de metadata JSON)
                view.setUint32(pos, 0, true); pos += 4;
                view.setUint32(pos, 0, true); pos += 4;
                view.setUint32(pos, 0, true); pos += 4;
                view.setUint32(pos, 0, true); pos += 4;
                // Tile bounds (simplifi√©)
                const minZ = this.tiles.length > 0 ? Math.min(...this.tiles.map(t => t.z)) : 0;
                const maxZ = this.tiles.length > 0 ? Math.max(...this.tiles.map(t => t.z)) : 0;
                view.setUint64(pos, 0n, true); pos += 8; // min pos
                view.setUint64(pos, (1n << BigInt(maxZ + 1)) - 1n, true); pos += 8; // max pos (full pyramid)

                // Data section : concat√©ner header + tiles data
                const dataSection = new Uint8Array(offset);
                dataSection.set(new Uint8Array(header), 0);

                let dataPos = 128;
                for (let tile of this.tiles) {
                    dataSection.set(tile.data, dataPos);
                    dataPos += tile.length;
                }

                // Directory section : 34 bytes par entry (zxy 6 bytes + address 8 + length 8 + 12 reserved)
                const dirSize = this.tiles.length * 34;
                const dirSection = new Uint8Array(dirSize);
                let dirPos = 0;
                for (let i = 0; i < this.tiles.length; i++) {
                    const tile = this.tiles[i];
                    const zxy = (BigInt(tile.z) << 56n) | (BigInt(tile.x) << 28n) | BigInt(tile.y); // 28 bits chacun
                    const addr64 = BigInt(entries[i].address);
                    const len64 = BigInt(entries[i].length);
                    // zxy (6 bytes LE)
                    dirSection.set(new Uint8Array(new BigUint64Array([zxy & 0xFFFFFFFFFFFFn])[0]), dirPos); dirPos += 6;
                    // Address (8 bytes LE)
                    dirSection.set(new Uint8Array(new BigUint64Array([addr64])[0]), dirPos); dirPos += 8;
                    // Length (8 bytes LE)
                    dirSection.set(new Uint8Array(new BigUint64Array([len64])[0]), dirPos); dirPos += 8;
                    // Reserved 12 bytes 0
                    dirPos += 12;
                }

                // Fichier final : data + directory
                const totalBuffer = new Uint8Array(dataSection.length + dirSize);
                totalBuffer.set(dataSection);
                totalBuffer.set(dirSection, dataSection.length);

                // Ajout JSON metadata √† la fin (optionnel)
                const jsonMeta = JSON.stringify(this.metadata);
                const jsonBytes = new TextEncoder().encode(jsonMeta);
                // Mais pour simplicit√©, on l'ignore dans ce writer basique

                return totalBuffer.buffer;
            }
        }

        async function generatePMTiles() {
            const radius = parseFloat(document.getElementById('radius').value);
            const minZoom = parseInt(document.getElementById('minZoom').value);
            const maxZoom = parseInt(document.getElementById('maxZoom').value);

            if (minZoom > maxZoom) {
                alert('Le zoom minimum doit √™tre inf√©rieur ou √©gal au zoom maximum');
                return;
            }

            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            const now = new Date();
            const filename = `trektiles-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;

            let fileHandle = null;
            if (directoryHandle === 'use_picker' && 'showSaveFilePicker' in window) {
                try {
                    const opts = {
                        suggestedName: filename + '.pmtiles',
                        types: [{
                            description: 'PMTiles Archive',
                            accept: { 'application/octet-stream': ['.pmtiles'] }
                        }]
                    };
                    fileHandle = await window.showSaveFilePicker(opts);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        alert('Sauvegarde annul√©e');
                        return;
                    }
                    console.error('Erreur s√©lection fichier:', error);
                }
            }

            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            progressFill.textContent = '0%';
            progressText.textContent = 'Initialisation du PMTiles...';

            try {
                const writer = new SimplePMTilesWriter();

                // Metadata basique
                writer.setMetadata('name', filename);
                writer.setMetadata('type', 'baselayer');
                writer.setMetadata('version', '1.0');
                writer.setMetadata('description', `Tuiles ${currentTileSource === 'osm' ? 'OSM' : 'IGN Plan v2'} g√©n√©r√©es par TrekTiles`);
                writer.setMetadata('format', 'png');
                writer.setMetadata('minzoom', minZoom);
                writer.setMetadata('maxzoom', maxZoom);
                writer.setMetadata('bounds', `${centerLon - 1},${centerLat - 1},${centerLon + 1},${centerLat + 1}`);
                writer.setMetadata('center', `${centerLon},${centerLat},${Math.round((minZoom + maxZoom) / 2)}`);
                writer.setMetadata('attribution', currentTileSource === 'osm' ? '¬© OpenStreetMap contributors' : '¬© IGN - Plan v2');

                let totalTiles = 0;
                let downloadedTiles = 0;
                for (let z = minZoom; z <= maxZoom; z++) {
                    const bounds = getTileBounds(centerLat, centerLon, radius, z);
                    const numTiles = (bounds.maxX - bounds.minX + 1) * (bounds.maxY - bounds.minY + 1);
                    totalTiles += numTiles;
                }

                progressText.textContent = `T√©l√©chargement de ${totalTiles} tuiles...`;

                for (let z = minZoom; z <= maxZoom; z++) {
                    const bounds = getTileBounds(centerLat, centerLon, radius, z);

                    for (let x = bounds.minX; x <= bounds.maxX; x++) {
                        for (let y = bounds.minY; y <= bounds.maxY; y++) {
                            try {
                                let url;
                                if (currentTileSource === 'osm') {
                                    url = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
                                } else if (currentTileSource === 'ign') {
                                    url = `https://data.geopf.fr/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2&STYLE=normal&FORMAT=image/png&TILEMATRIXSET=PM&TILEMATRIX=${z}&TILEROW=${y}&TILECOL=${x}`;
                                }

                                const response = await fetch(url);
                                if (!response.ok) continue;
                                const arrayBuffer = await response.arrayBuffer();
                                writer.addTile(z, x, y, arrayBuffer);

                                downloadedTiles++;
                                const progress = Math.round((downloadedTiles / totalTiles) * 100);
                                progressFill.style.width = progress + '%';
                                progressFill.textContent = progress + '%';
                                progressText.textContent = `T√©l√©chargement: ${downloadedTiles} / ${totalTiles} tuiles (zoom ${z})`;

                                // D√©lai anti-surcharge
                                await new Promise(resolve => setTimeout(resolve, 50));
                            } catch (error) {
                                console.error(`Erreur tuile ${z}/${x}/${y}:`, error);
                            }
                        }
                    }
                }

                progressText.textContent = 'Finalisation du fichier PMTiles...';
                const data = await writer.finish();
                const blob = new Blob([data], { type: 'application/octet-stream' });

                if (fileHandle) {
                    try {
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        progressText.textContent = `‚úÖ Termin√©! ${downloadedTiles} tuiles t√©l√©charg√©es. Fichier: ${filename}.pmtiles`;
                    } catch (error) {
                        console.error('Erreur √©criture:', error);
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = filename + '.pmtiles';
                        a.click();
                        progressText.textContent = `‚úÖ Termin√©! (t√©l√©chargement classique) ${downloadedTiles} tuiles`;
                    }
                } else {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename + '.pmtiles';
                    a.click();
                    progressText.textContent = `‚úÖ Termin√©! ${downloadedTiles} tuiles t√©l√©charg√©es.`;
                }

                progressFill.style.width = '100%';
                progressFill.textContent = '100%';
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 5000);
            } catch (error) {
                console.error('Erreur g√©n√©ration:', error);
                progressText.textContent = '‚ùå Erreur: ' + error.message;
            }
        }

        window.addEventListener('load', initMap);
    </script>
</body>
</html>