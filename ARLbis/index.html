<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Générateur SQLITEDB OsmAnd</title>

<style>
body {
    font-family: Arial, sans-serif;
    padding: 15px;
}
#progressContainer {
    width: 100%;
    background: #ddd;
    height: 25px;
    margin-top: 15px;
    border-radius: 4px;
    overflow: hidden;
}
#progressFill {
    background: #4caf50;
    width: 0%;
    height: 100%;
    color: white;
    text-align: center;
    line-height: 25px;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
</head>

<body>

<h2>Générateur de cartes SQLiteDB (OSM / GEOFR)</h2>

<label>Latitude :</label>
<input id="lat" type="number" step="0.000001" value="48.8584"><br><br>

<label>Longitude :</label>
<input id="lon" type="number" step="0.000001" value="2.2945"><br><br>

<label>Rayon (km) :</label>
<input id="radius" type="number" value="2"><br><br>

<label>Niveau zoom min :</label>
<input id="minZoom" type="number" value="12"><br><br>

<label>Niveau zoom max :</label>
<input id="maxZoom" type="number" value="16"><br><br>

<label>Source :</label>
<select id="source">
    <option value="osm">OpenStreetMap</option>
    <option value="ign">IGN France (PlanV2)</option>
</select>

<br><br>
<button id="generateBtn">Créer le SQLITEDB</button>

<div id="progressContainer">
    <div id="progressFill">0%</div>
</div>

<p id="progressText"></p>

<script>
// -----------------------------------------------------------
//     GÉNÉRATION SQLITEDB COMPATIBLE OSMAND / BIGPLANET
// -----------------------------------------------------------

// Conversion lat/lon -> tuiles
function long2tile(lon, zoom) {
    return Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
}
function lat2tile(lat, zoom) {
    return Math.floor(
        (1 - Math.log(Math.tan(lat * Math.PI / 180) +
         1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)
    );
}

// Rayon → rectangle tuilé
function getTileBounds(lat, lon, radiusKm, zoom) {
    const earth = 6371;
    const dLat = (radiusKm / earth) * (180 / Math.PI);
    const dLon = (radiusKm / (earth * Math.cos(lat * Math.PI / 180))) * (180 / Math.PI);

    const latMin = lat - dLat;
    const latMax = lat + dLat;
    const lonMin = lon - dLon;
    const lonMax = lon + dLon;

    const minX = long2tile(lonMin, zoom);
    const maxX = long2tile(lonMax, zoom);
    const minY = lat2tile(latMax, zoom);
    const maxY = lat2tile(latMin, zoom);

    return { minX, maxX, minY, maxY };
}

document.getElementById('generateBtn').onclick = async function () {

    const centerLat = parseFloat(document.getElementById("lat").value);
    const centerLon = parseFloat(document.getElementById("lon").value);
    const radius = parseFloat(document.getElementById("radius").value);
    const minZoom = parseInt(document.getElementById("minZoom").value);
    const maxZoom = parseInt(document.getElementById("maxZoom").value);
    const source = document.getElementById("source").value;

    const progressFill = document.getElementById("progressFill");
    const progressText = document.getElementById("progressText");

    progressText.textContent = "Initialisation de la base SQLite…";

    // Chargement SQL.js
    const SQL = await initSqlJs({
        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
    });

    const db = new SQL.Database();

    // ---------------------- FORMAT CORRECT OSMAND ------------------------
    db.run(`CREATE TABLE info (version INTEGER, compressed INTEGER, date INTEGER, name TEXT)`);
    db.run(`INSERT INTO info VALUES (2, 0, ${Math.floor(Date.now()/1000)}, 'Generated Map')`);

    db.run(`CREATE TABLE tiles (
        x INTEGER,
        y INTEGER,
        z INTEGER,
        image BLOB,
        s INTEGER,
        PRIMARY KEY (x,y,z,s)
    );`);

    db.run(`CREATE TABLE patterns (pattern BLOB);`);
    db.run(`CREATE INDEX IND on tiles (x, y, z, s);`);
    // ---------------------------------------------------------------------

    let totalTiles = 0;
    let downloadedTiles = 0;

    // Comptage des tuiles
    for (let z = minZoom; z <= maxZoom; z++) {
        const b = getTileBounds(centerLat, centerLon, radius, z);
        totalTiles += (b.maxX - b.minX + 1) * (b.maxY - b.minY + 1);
    }

    progressText.textContent = `Téléchargement de ${totalTiles} tuiles…`;

    for (let z = minZoom; z <= maxZoom; z++) {

        const bounds = getTileBounds(centerLat, centerLon, radius, z);

        for (let x = bounds.minX; x <= bounds.maxX; x++) {
            for (let y = bounds.minY; y <= bounds.maxY; y++) {

                // TMS inversion Y
                const tmsY = (Math.pow(2, z) - 1) - y;

                let url = "";

                if (source === "osm") {
                    url = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
                } else {
                    url =
                        `https://data.geopf.fr/wmts?SERVICE=WMTS&REQUEST=GetTile` +
                        `&VERSION=1.0.0&LAYER=GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2` +
                        `&STYLE=normal&FORMAT=image/png&TILEMATRIXSET=PM` +
                        `&TILEMATRIX=${z}&TILEROW=${y}&TILECOL=${x}`;
                }

                try {
                    const response = await fetch(url);
                    const blob = await response.blob();
                    const bytes = new Uint8Array(await blob.arrayBuffer());

                    // OSMAND : zoom inversé
                    const osmandZ = maxZoom - z;

                    db.run(
                        "INSERT INTO tiles VALUES (?, ?, ?, ?, ?)",
                        [x, tmsY, osmandZ, bytes, 0]
                    );

                } catch (err) {
                    console.error("Erreur tuile", z, x, y, err);
                }

                downloadedTiles++;
                const percent = Math.round((downloadedTiles / totalTiles) * 100);
                progressFill.style.width = percent + "%";
                progressFill.textContent = percent + "%";
                progressText.textContent =
                    `Téléchargement : ${downloadedTiles}/${totalTiles}`;
            }
        }
    }

    progressText.textContent = "Création du fichier…";

    const finalData = db.export();
    const blob = new Blob([finalData], { type: "application/x-sqlite3" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "map.sqlitedb";
    a.click();

    progressText.textContent = "Terminé !";
};
</script>

</body>
</html>
