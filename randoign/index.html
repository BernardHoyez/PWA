<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RandoIGN - Téléchargeur de Tuiles IGN Plan V2</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2196F3">
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f5f5f5; }
        #map { height: 400px; width: 100%; border: 1px solid #ccc; margin-bottom: 10px; }
        input, button { padding: 8px; margin: 5px; width: 100%; box-sizing: border-box; }
        #status { padding: 10px; background: #e3f2fd; border-radius: 4px; margin: 10px 0; }
        .hidden { display: none; }
        select { padding: 8px; margin: 5px; width: 100%; box-sizing: border-box; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js"></script>
</head>
<body>
    <h1>RandoIGN</h1>
    <p>Enregistrez une position A et téléchargez les tuiles IGN Plan V2 dans un rayon.</p>

    <!-- Sélection layer -->
    <h2>Layer Carte</h2>
    <select id="layerSelect" onchange="switchLayer()">
        <option value="plan">Plan IGN V2 (vectoriel)</option>
        <option value="ortho">Orthophotos (images)</option>
    </select>

    <!-- Sélection position A -->
    <h2>Position A</h2>
    <button onclick="getCurrentPosition()">GPS Actuel</button>
    <input type="number" id="lat" placeholder="Latitude" step="any">
    <input type="number" id="lon" placeholder="Longitude" step="any">
    <button onclick="setManualPosition()">Manuel</button>
    <div id="map"></div>
    <button onclick="onMapClick(event)">Pointer sur Carte</button> <!-- Note: événement géré dans le script -->

    <!-- Rayon -->
    <h2>Rayon (km, <10)</h2>
    <input type="number" id="rayon" placeholder="Ex: 5" min="1" max="9" value="5">

    <!-- Bouton téléchargement -->
    <button onclick="downloadTiles()" style="background: #4CAF50; color: white; font-weight: bold;">Télécharger Tuiles (Zoom 12-16)</button>

    <!-- Statut -->
    <div id="status"></div>

    <script>
        let map, position = { lat: 48.8566, lon: 2.3522 }; // Paris par défaut
        let currentLayer = 'plan'; // Par défaut Plan IGN V2
        let planLayer, orthoLayer;

        // Initialiser carte avec nouveau WMTS
        function initMap() {
            map = new ol.Map({
                target: 'map',
                layers: [],
                view: new ol.View({
                    center: ol.proj.fromLonLat([position.lon, position.lat]),
                    zoom: 14
                })
            });

            // Layer Plan IGN V2
            planLayer = new ol.layer.Tile({
                source: new ol.source.WMTS({
                    url: 'https://data.geopf.fr/wmts',
                    layer: 'GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2',
                    matrixSet: 'PM',
                    format: 'image/png',
                    projection: 'EPSG:3857',
                    tileGrid: ol.tilegrid.createXYZ({ maxZoom: 20 }),
                    style: 'normal',
                    wrapX: true,
                    attributions: '© IGN / GéoPlateforme - Plan IGN v2'
                }),
                visible: true
            });

            // Layer Orthophotos
            orthoLayer = new ol.layer.Tile({
                source: new ol.source.WMTS({
                    url: 'https://data.geopf.fr/wmts',
                    layer: 'ORTHOIMAGERY.ORTHOPHOTOS',
                    matrixSet: 'PM',
                    format: 'image/jpeg',
                    projection: 'EPSG:3857',
                    tileGrid: ol.tilegrid.createXYZ({ maxZoom: 20 }),
                    style: 'normal',
                    wrapX: true,
                    attributions: '© IGN / GéoPlateforme - Orthophotos'
                }),
                visible: false
            });

            map.addLayer(planLayer);
            map.addLayer(orthoLayer);

            // Événement clic carte
            map.on('singleclick', (evt) => {
                const coord = ol.proj.toLonLat(evt.coordinate);
                position = { lat: coord[1], lon: coord[0] };
                updateStatus(`Position pointée: ${position.lat.toFixed(6)}, ${position.lon.toFixed(6)}`);
                map.getView().setCenter(evt.coordinate);
            });
        }

        // Basculer layer
        function switchLayer() {
            currentLayer = document.getElementById('layerSelect').value;
            planLayer.setVisible(currentLayer === 'plan');
            orthoLayer.setVisible(currentLayer === 'ortho');
        }

        initMap(); // Appel initial

        // GPS
        function getCurrentPosition() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition((p) => {
                    position = { lat: p.coords.latitude, lon: p.coords.longitude };
                    updateStatus(`GPS: ${position.lat.toFixed(6)}, ${position.lon.toFixed(6)}`);
                    map.getView().setCenter(ol.proj.fromLonLat([position.lon, position.lat]));
                });
            }
        }

        // Manuel
        function setManualPosition() {
            const lat = parseFloat(document.getElementById('lat').value);
            const lon = parseFloat(document.getElementById('lon').value);
            if (!isNaN(lat) && !isNaN(lon)) {
                position = { lat, lon };
                updateStatus(`Manuel: ${lat.toFixed(6)}, ${lon.toFixed(6)}`);
                map.getView().setCenter(ol.proj.fromLonLat([lon, lat]));
            }
        }

        // Clic sur bouton pour focus (optionnel, mais le clic sur carte est déjà géré)
        function onMapClick(event) {
            // Placeholder si besoin, mais événement map.on('singleclick') gère déjà
            updateStatus('Cliquez directement sur la carte pour sélectionner le point.');
        }

        // Distance haversine
        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371; // km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Téléchargement tuiles avec nouveau URL
        async function downloadTiles() {
            const rayon = parseInt(document.getElementById('rayon').value);
            if (rayon >= 10 || rayon < 1) return updateStatus('Rayon invalide (1-9 km).');

            const layer = currentLayer === 'plan' ? 'GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2' : 'ORTHOIMAGERY.ORTHOPHOTOS';
            const format = currentLayer === 'plan' ? 'image/png' : 'image/jpeg';

            updateStatus('Initialisation DB MBTiles...');
            const SQL = await initSqlJs({ locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}` });
            const db = new SQL.Database();

            // Créer table metadata et tiles
            db.run("CREATE TABLE metadata (name text, value text);");
            db.run("CREATE TABLE tiles (zoom_level integer, tile_column integer, tile_row integer, tile_data blob);");
            db.run("CREATE UNIQUE INDEX tile_index ON tiles(zoom_level, tile_column, tile_row);");
            db.run("INSERT INTO metadata (name, value) VALUES ('name', 'randoign_tiles'), ('format', '" + format + "'), ('version', '1.3');");

            let count = 0;
            for (let z = 12; z <= 16; z++) {
                const n = Math.pow(2, z);
                const centerX = Math.floor((position.lon + 180) / 360 * n);
                const centerY = Math.floor((1 - Math.log(Math.tan(position.lat * Math.PI / 180) + 1 / Math.cos(position.lat * Math.PI / 180)) / Math.PI) / 2 * n);
                const radiusTiles = Math.ceil((rayon / 40075) * n * 360); // Approx tiles rayon

                for (let dx = -radiusTiles; dx <= radiusTiles; dx++) {
                    for (let dy = -radiusTiles; dy <= radiusTiles; dy++) {
                        const tx = centerX + dx;
                        const ty = centerY + dy;
                        if (tx < 0 || tx >= n || ty < 0 || ty >= n) continue;

                        // Lat/lon du tile center (approx)
                        const lonTile = tx / n * 360 - 180;
                        const latTile = Math.atan(Math.sinh(Math.PI * (1 - 2 * ty / n))) * 180 / Math.PI;
                        if (haversine(position.lat, position.lon, latTile, lonTile) > rayon) continue;

                        const url = `https://data.geopf.fr/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&FORMAT=${format}&STYLE=normal&TILEMATRIXSET=PM&TILEMATRIX=${z}&TILEROW=${ty}&TILECOL=${tx}&LAYER=${layer}`;
                        try {
                            const response = await fetch(url);
                            const blob = await response.blob();
                            const arrayBuffer = await blob.arrayBuffer();
                            const tileData = new Uint8Array(arrayBuffer);
                            db.run("INSERT OR REPLACE INTO tiles VALUES (?, ?, ?, ?);", [z, tx, ty, tileData]);
                            count++;
                        } catch (e) {
                            console.error('Erreur tile:', e);
                        }
                    }
                }
            }

            // Exporter MBTiles
            const data = db.export();
            const blob = new Blob([data], { type: 'application/octet-stream' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `tiles_${currentLayer}_${position.lat.toFixed(4)}_${position.lon.toFixed(4)}_r${rayon}km.mbtiles`;
            a.click();
            updateStatus(`Téléchargement terminé: ${count} tuiles sauvegardées (${currentLayer}).`);
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }

        // Enregistrer SW
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js');
        }
    </script>
</body>
</html>