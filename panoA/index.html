<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>panoA - Assembleur Panoramique</title>
  <meta name="description" content="Assemblage intelligent de panoramas drone avec détection de points clés et homographies">
  <meta name="theme-color" content="#0e7490">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="icon192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icon512.png">
  <link rel="apple-touch-icon" href="icon192.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 50%, #0e7490 100%);
      min-height: 100vh;
      padding: 1rem;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    .card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    }
    .header { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; }
    h1 { font-size: 1.875rem; font-weight: 700; color: white; }
    h2 { font-size: 1.25rem; font-weight: 600; color: white; }
    h3 { font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem; }
    .text-sm { font-size: 0.875rem; color: #a5f3fc; }
    .btn-group { display: flex; gap: 1rem; margin-bottom: 1.5rem; }
    .btn {
      flex: 1;
      padding: 1rem;
      border: none;
      border-radius: 0.5rem;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.3s;
      color: white;
      font-size: 1rem;
    }
    .btn-cyan { background: #06b6d4; }
    .btn-cyan:hover { background: #0891b2; }
    .btn-green { background: #22c55e; }
    .btn-green:hover { background: #16a34a; }
    .btn-red { background: #ef4444; flex: 0 0 auto; }
    .btn-red:hover { background: #dc2626; }
    .btn-purple { background: #a855f7; padding: 0.5rem 1rem; flex: 0 0 auto; }
    .btn-purple:hover { background: #9333ea; }
    .btn:disabled { background: #6b7280; cursor: not-allowed; opacity: 0.6; }
    .icon { width: 1.25rem; height: 1.25rem; }
    .icon-lg { width: 2rem; height: 2rem; }
    input[type="file"] { display: none; }
    .progress {
      background: rgba(59, 130, 246, 0.2);
      border: 1px solid #60a5fa;
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-bottom: 1rem;
    }
    .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; }
    @media (min-width: 768px) { .grid { grid-template-columns: repeat(4, 1fr); } }
    .img-card { position: relative; border-radius: 0.5rem; overflow: hidden; }
    .img-card img { width: 100%; height: 8rem; object-fit: cover; display: block; }
    .img-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 0.75rem;
      padding: 0.25rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .result-container { border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 1.5rem; margin-top: 1.5rem; }
    .result-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; }
    .result-image { background: rgba(0, 0, 0, 0.3); border-radius: 0.5rem; padding: 0.5rem; overflow: auto; }
    .result-image img { max-width: 100%; height: auto; border-radius: 0.25rem; display: block; }
    ul { list-style: disc; padding-left: 1.5rem; }
    ul li { margin-bottom: 0.5rem; color: #a5f3fc; }
    .footer { text-align: center; color: #a5f3fc; font-size: 0.875rem; }
    .spin { animation: spin 1s linear infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="module">
    import React, { useState } from 'https://esm.sh/react@18';
    import ReactDOM from 'https://esm.sh/react-dom@18/client';

    const Camera = () => React.createElement('svg', { className: 'icon-lg', fill: 'none', stroke: '#67e8f9', strokeWidth: 2, viewBox: '0 0 24 24' },
      React.createElement('path', { d: 'M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z' }),
      React.createElement('circle', { cx: 12, cy: 13, r: 4 })
    );

    const Upload = () => React.createElement('svg', { className: 'icon', fill: 'none', stroke: 'currentColor', strokeWidth: 2, viewBox: '0 0 24 24' },
      React.createElement('path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12' })
    );

    const Layers = () => React.createElement('svg', { className: 'icon', fill: 'none', stroke: 'currentColor', strokeWidth: 2, viewBox: '0 0 24 24' },
      React.createElement('polygon', { points: '12 2 2 7 12 12 22 7 12 2' }),
      React.createElement('polyline', { points: '2 17 12 22 22 17' }),
      React.createElement('polyline', { points: '2 12 12 17 22 12' })
    );

    const Loader = () => React.createElement('svg', { className: 'icon spin', fill: 'none', stroke: 'currentColor', strokeWidth: 2, viewBox: '0 0 24 24' },
      React.createElement('path', { d: 'M21 12a9 9 0 1 1-6.219-8.56' })
    );

    const Trash = () => React.createElement('svg', { className: 'icon', fill: 'none', stroke: 'currentColor', strokeWidth: 2, viewBox: '0 0 24 24' },
      React.createElement('path', { d: 'M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2' })
    );

    const Download = () => React.createElement('svg', { className: 'icon', fill: 'none', stroke: 'currentColor', strokeWidth: 2, viewBox: '0 0 24 24' },
      React.createElement('path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3' })
    );

    const Info = () => React.createElement('svg', { className: 'icon', fill: 'none', stroke: '#67e8f9', strokeWidth: 2, viewBox: '0 0 24 24' },
      React.createElement('circle', { cx: 12, cy: 12, r: 10 }),
      React.createElement('path', { d: 'M12 16v-4M12 8h.01' })
    );

    const PanoA = () => {
      const [images, setImages] = useState([]);
      const [processing, setProcessing] = useState(false);
      const [result, setResult] = useState(null);
      const [progress, setProgress] = useState('');

      const detectFAST = (imageData, threshold = 30) => {
        const { width, height, data } = imageData;
        const keypoints = [];
        for (let y = 3; y < height - 3; y++) {
          for (let x = 3; x < width - 3; x++) {
            const idx = (y * width + x) * 4;
            const centerValue = data[idx];
            const circle = [[0, -3], [1, -3], [2, -2], [3, -1], [3, 0], [3, 1], [2, 2], [1, 3], [0, 3], [-1, 3], [-2, 2], [-3, 1], [-3, 0], [-3, -1], [-2, -2], [-1, -3]];
            let brighter = 0, darker = 0;
            for (const [dx, dy] of circle) {
              const px = x + dx, py = y + dy;
              const pidx = (py * width + px) * 4;
              const val = data[pidx];
              if (val > centerValue + threshold) brighter++;
              if (val < centerValue - threshold) darker++;
            }
            if (brighter >= 12 || darker >= 12) {
              keypoints.push({ x, y, response: Math.max(brighter, darker) });
            }
          }
        }
        return keypoints.sort((a, b) => b.response - a.response).slice(0, 500);
      };

      const computeDescriptor = (imageData, kp, patchSize = 16) => {
        const { width, data } = imageData;
        const descriptor = [];
        const half = Math.floor(patchSize / 2);
        for (let dy = -half; dy < half; dy++) {
          for (let dx = -half; dx < half; dx++) {
            const x = kp.x + dx, y = kp.y + dy;
            if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {
              const idx = (y * width + x) * 4;
              descriptor.push(data[idx]);
            }
          }
        }
        return descriptor;
      };

      const matchDescriptors = (desc1, desc2, kp1, kp2) => {
        const matches = [];
        for (let i = 0; i < desc1.length; i++) {
          let bestDist = Infinity, secondBest = Infinity, bestIdx = -1;
          for (let j = 0; j < desc2.length; j++) {
            let dist = 0;
            const minLen = Math.min(desc1[i].length, desc2[j].length);
            for (let k = 0; k < minLen; k++) {
              const diff = desc1[i][k] - desc2[j][k];
              dist += diff * diff;
            }
            if (dist < bestDist) {
              secondBest = bestDist;
              bestDist = dist;
              bestIdx = j;
            } else if (dist < secondBest) {
              secondBest = dist;
            }
          }
          if (bestDist < 0.7 * secondBest && bestIdx !== -1) {
            matches.push({ p1: kp1[i], p2: kp2[bestIdx], distance: bestDist });
          }
        }
        return matches;
      };

      const assemblePanorama = async () => {
        if (images.length < 2) { alert('Veuillez charger au moins 2 images'); return; }
        setProcessing(true);
        setProgress('Chargement des images...');
        try {
          const imgElements = await Promise.all(images.map(img => new Promise((resolve) => {
            const el = new Image();
            el.onload = () => resolve(el);
            el.src = img.url;
          })));
          setProgress('Détection des points clés FAST...');
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const features = imgElements.map(img => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            const keypoints = detectFAST(imageData);
            const descriptors = keypoints.map(kp => computeDescriptor(imageData, kp));
            return { imageData, keypoints, descriptors, img };
          });
          setProgress('Calcul des correspondances...');
          const brightnesses = features.map(f => {
            const sum = f.imageData.data.reduce((s, v, i) => i % 4 === 3 ? s : s + v, 0);
            return sum / (f.imageData.data.length * 3 / 4);
          });
          const avgBrightness = brightnesses.reduce((a, b) => a + b) / brightnesses.length;
          let totalWidth = features[0].img.width;
          for (let i = 1; i < features.length; i++) {
            const matches = matchDescriptors(features[i - 1].descriptors, features[i].descriptors, features[i - 1].keypoints, features[i].keypoints);
            if (matches.length > 0) {
              const avgOffset = matches.reduce((sum, m) => sum + (m.p2.x - m.p1.x), 0) / matches.length;
              totalWidth += features[i].img.width - Math.abs(avgOffset);
            } else {
              totalWidth += features[i].img.width * 0.7;
            }
          }
          const maxHeight = Math.max(...features.map(f => f.img.height));
          canvas.width = totalWidth;
          canvas.height = maxHeight;
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, totalWidth, maxHeight);
          let xOffset = 0;
          for (let i = 0; i < features.length; i++) {
            setProgress(`Fusion avec correction lumière ${i + 1}/${features.length}...`);
            const img = features[i].img;
            const factor = avgBrightness / brightnesses[i];
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            const tempData = tempCtx.getImageData(0, 0, img.width, img.height);
            for (let j = 0; j < tempData.data.length; j += 4) {
              tempData.data[j] = Math.min(255, tempData.data[j] * factor);
              tempData.data[j + 1] = Math.min(255, tempData.data[j + 1] * factor);
              tempData.data[j + 2] = Math.min(255, tempData.data[j + 2] * factor);
            }
            tempCtx.putImageData(tempData, 0, 0);
            if (i > 0) {
              const blendWidth = img.width * 0.15;
              for (let x = 0; x < blendWidth; x++) {
                const alpha = x / blendWidth;
                ctx.globalAlpha = alpha;
                ctx.drawImage(tempCanvas, x, 0, 1, img.height, xOffset + x, 0, 1, img.height);
              }
              ctx.globalAlpha = 1;
              ctx.drawImage(tempCanvas, blendWidth, 0, img.width - blendWidth, img.height, xOffset + blendWidth, 0, img.width - blendWidth, img.height);
              xOffset += img.width * 0.7;
            } else {
              ctx.drawImage(tempCanvas, xOffset, 0);
              xOffset += img.width * 0.7;
            }
          }
          setProgress('Assemblage terminé !');
          setResult(canvas.toDataURL('image/png'));
        } catch (error) {
          console.error('Erreur:', error);
          setProgress('Erreur: ' + error.message);
        } finally {
          setProcessing(false);
        }
      };

      const handleFileUpload = (e) => {
        const files = Array.from(e.target.files);
        const newImages = files.map(file => ({ url: URL.createObjectURL(file), name: file.name }));
        setImages([...images, ...newImages]);
        setResult(null);
      };

      const downloadResult = () => {
        if (!result) return;
        const link = document.createElement('a');
        link.href = result;
        link.download = 'panorama.png';
        link.click();
      };

      return React.createElement('div', { className: 'container' },
        React.createElement('div', { className: 'card' },
          React.createElement('div', { className: 'header' }, React.createElement(Camera), React.createElement('h1', null, 'panoA')),
          React.createElement('p', { className: 'text-sm' }, 'Assembleur panoramique intelligent pour photos de drone')
        ),
        React.createElement('div', { className: 'card' },
          React.createElement('div', { className: 'header' }, React.createElement(Info), React.createElement('h2', null, 'Instructions')),
          React.createElement('ul', { className: 'text-sm' },
            React.createElement('li', null, 'Chargez au moins 2 images avec recouvrement latéral'),
            React.createElement('li', null, 'Détection automatique de points clés (FAST)'),
            React.createElement('li', null, 'Calcul des homographies via correspondances'),
            React.createElement('li', null, 'Normalisation automatique de la luminosité')
          )
        ),
        React.createElement('div', { className: 'card' },
          React.createElement('div', { className: 'btn-group' },
            React.createElement('label', { className: 'btn btn-cyan' },
              React.createElement(Upload), React.createElement('span', null, 'Charger'),
              React.createElement('input', { type: 'file', multiple: true, accept: 'image/*', onChange: handleFileUpload })
            ),
            React.createElement('button', { onClick: assemblePanorama, disabled: images.length < 2 || processing, className: 'btn btn-green' },
              processing ? React.createElement(Loader) : React.createElement(Layers),
              React.createElement('span', null, processing ? 'Assemblage...' : 'Assembler')
            ),
            React.createElement('button', { onClick: () => setImages([]), disabled: images.length === 0, className: 'btn btn-red' }, React.createElement(Trash))
          ),
          progress && React.createElement('div', { className: 'progress' }, React.createElement('p', { className: 'text-sm' }, progress)),
          images.length > 0 && React.createElement('div', null,
            React.createElement('h3', null, `Images chargées (${images.length})`),
            React.createElement('div', { className: 'grid' }, images.map((img, idx) =>
              React.createElement('div', { key: idx, className: 'img-card' },
                React.createElement('img', { src: img.url, alt: img.name }),
                React.createElement('div', { className: 'img-label' }, img.name)
              )
            ))
          ),
          result && React.createElement('div', { className: 'result-container' },
            React.createElement('div', { className: 'result-header' },
              React.createElement('h3', null, 'Panorama assemblé'),
              React.createElement('button', { onClick: downloadResult, className: 'btn btn-purple' },
                React.createElement(Download), React.createElement('span', null, 'Télécharger')
              )
            ),
            React.createElement('div', { className: 'result-image' }, React.createElement('img', { src: result, alt: 'Panorama' }))
          )
        ),
        React.createElement('div', { className: 'footer' }, React.createElement('p', null, 'Vision par ordinateur • Détection FAST • Homographies • Correction lumière'))
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(PanoA));

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').then(reg => console.log('SW enregistré', reg)).catch(err => console.log('SW erreur', err));
      });
    }
  </script>
</body>
</html>