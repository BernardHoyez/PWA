<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>panoA - Assembleur Panoramique</title>
  <meta name="description" content="Assemblage intelligent de panoramas drone avec détection de points clés et homographies">
  <meta name="theme-color" content="#0e7490">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="icon192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icon512.png">
  <link rel="apple-touch-icon" href="icon192.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 50%, #0e7490 100%);
      min-height: 100vh;
      padding: 1rem;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    .card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    }
    .header { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; }
    h1 { font-size: 1.875rem; font-weight: 700; color: white; }
    h2 { font-size: 1.25rem; font-weight: 600; color: white; }
    h3 { font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem; }
    .text-sm { font-size: 0.875rem; color: #a5f3fc; }
    .text-xs { font-size: 0.75rem; color: #86efac; font-family: monospace; }
    .btn-group { display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
    .btn {
      flex: 1;
      min-width: 150px;
      padding: 1rem;
      border: none;
      border-radius: 0.5rem;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.3s;
      color: white;
      font-size: 1rem;
    }
    .btn-cyan { background: #06b6d4; }
    .btn-cyan:hover { background: #0891b2; }
    .btn-green { background: #22c55e; }
    .btn-green:hover { background: #16a34a; }
    .btn-red { background: #ef4444; flex: 0 0 auto; min-width: auto; }
    .btn-red:hover { background: #dc2626; }
    .btn-purple { background: #a855f7; padding: 0.5rem 1rem; flex: 0 0 auto; min-width: auto; }
    .btn-purple:hover { background: #9333ea; }
    .btn:disabled { background: #6b7280; cursor: not-allowed; opacity: 0.6; }
    .icon { width: 1.25rem; height: 1.25rem; }
    .icon-lg { width: 2rem; height: 2rem; }
    input[type="file"] { display: none; }
    .progress {
      background: rgba(59, 130, 246, 0.2);
      border: 1px solid #60a5fa;
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-bottom: 1rem;
    }
    .matches-info {
      background: rgba(34, 197, 94, 0.2);
      border: 1px solid #4ade80;
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-bottom: 1rem;
    }
    .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; }
    @media (min-width: 768px) { .grid { grid-template-columns: repeat(4, 1fr); } }
    .img-card { position: relative; border-radius: 0.5rem; overflow: hidden; }
    .img-card img { width: 100%; height: 8rem; object-fit: cover; display: block; }
    .img-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 0.75rem;
      padding: 0.25rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .result-container { border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 1.5rem; margin-top: 1.5rem; }
    .result-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem; }
    .result-image { background: rgba(0, 0, 0, 0.3); border-radius: 0.5rem; padding: 0.5rem; overflow: auto; }
    .result-image img { max-width: 100%; height: auto; border-radius: 0.25rem; display: block; }
    ul { list-style: disc; padding-left: 1.5rem; }
    ul li { margin-bottom: 0.5rem; color: #a5f3fc; }
    .footer { text-align: center; color: #a5f3fc; font-size: 0.875rem; }
    .spin { animation: spin 1s linear infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="header">
        <svg class="icon-lg" fill="none" stroke="#67e8f9" stroke-width="2" viewBox="0 0 24 24">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
          <circle cx="12" cy="13" r="4"/>
        </svg>
        <h1>panoA</h1>
      </div>
      <p class="text-sm">Véritable assemblage panoramique avec système de coordonnées commun</p>
    </div>

    <div class="card">
      <div class="header">
        <svg class="icon" fill="none" stroke="#67e8f9" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10"/>
          <path d="M12 16v-4M12 8h.01"/>
        </svg>
        <h2>Instructions</h2>
      </div>
      <ul class="text-sm">
        <li>Chargez 2+ images avec recouvrement latéral (30-70%)</li>
        <li>Image centrale = référence du système de coordonnées</li>
        <li>Toutes les autres images transformées vers cette référence</li>
        <li>Composition des homographies pour alignement global</li>
        <li>Chaque pixel mappé une seule fois - pas de duplication</li>
      </ul>
    </div>

    <div class="card">
      <div class="btn-group">
        <label class="btn btn-cyan" for="fileInput">
          <svg class="icon" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
          </svg>
          <span>Charger des images</span>
        </label>
        <input type="file" id="fileInput" multiple accept="image/*">
        
        <button id="assembleBtn" class="btn btn-green" disabled>
          <svg class="icon" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <polygon points="12 2 2 7 12 12 22 7 12 2"/>
            <polyline points="2 17 12 22 22 17"/>
            <polyline points="2 12 12 17 22 12"/>
          </svg>
          <span>Assembler</span>
        </button>

        <button id="clearBtn" class="btn btn-red" disabled>
          <svg class="icon" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
      </div>

      <div id="progressBox" class="progress hidden">
        <p class="text-sm" id="progressText"></p>
      </div>

      <div id="matchesBox" class="matches-info hidden">
        <p class="text-xs" id="matchesText"></p>
      </div>

      <div id="imagesContainer" class="hidden">
        <h3 id="imagesTitle"></h3>
        <div class="grid" id="imagesGrid"></div>
      </div>

      <div id="resultContainer" class="result-container hidden">
        <div class="result-header">
          <h3>Panorama assemblé</h3>
          <button id="downloadBtn" class="btn btn-purple">
            <svg class="icon" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/>
            </svg>
            <span>Télécharger</span>
          </button>
        </div>
        <div class="result-image">
          <img id="resultImage" alt="Panorama">
        </div>
      </div>
    </div>

    <div class="footer">
      <p>FAST • RANSAC • DLT • Composition homographies • Référentiel commun • Zero duplication</p>
    </div>
  </div>

  <script>
    let images = [];
    let resultDataUrl = null;

    const fileInput = document.getElementById('fileInput');
    const assembleBtn = document.getElementById('assembleBtn');
    const clearBtn = document.getElementById('clearBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const progressBox = document.getElementById('progressBox');
    const progressText = document.getElementById('progressText');
    const matchesBox = document.getElementById('matchesBox');
    const matchesText = document.getElementById('matchesText');
    const imagesContainer = document.getElementById('imagesContainer');
    const imagesTitle = document.getElementById('imagesTitle');
    const imagesGrid = document.getElementById('imagesGrid');
    const resultContainer = document.getElementById('resultContainer');
    const resultImage = document.getElementById('resultImage');

    fileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      files.forEach(file => {
        images.push({
          url: URL.createObjectURL(file),
          name: file.name
        });
      });
      updateUI();
    });

    clearBtn.addEventListener('click', () => {
      images = [];
      resultDataUrl = null;
      updateUI();
    });

    downloadBtn.addEventListener('click', () => {
      if (resultDataUrl) {
        const link = document.createElement('a');
        link.href = resultDataUrl;
        link.download = 'panorama.png';
        link.click();
      }
    });

    assembleBtn.addEventListener('click', assemblePanorama);

    function updateUI() {
      assembleBtn.disabled = images.length < 2;
      clearBtn.disabled = images.length === 0;
      
      if (images.length > 0) {
        imagesContainer.classList.remove('hidden');
        imagesTitle.textContent = `Images chargées (${images.length})`;
        imagesGrid.innerHTML = '';
        images.forEach((img, idx) => {
          const div = document.createElement('div');
          div.className = 'img-card';
          div.innerHTML = `
            <img src="${img.url}" alt="${img.name}">
            <div class="img-label">${img.name}</div>
          `;
          imagesGrid.appendChild(div);
        });
      } else {
        imagesContainer.classList.add('hidden');
        resultContainer.classList.add('hidden');
        matchesBox.classList.add('hidden');
      }
    }

    function setProgress(text) {
      progressText.textContent = text;
      progressBox.classList.remove('hidden');
    }

    function setMatches(text) {
      matchesText.textContent = text;
      matchesBox.classList.remove('hidden');
    }

    // Détection de points clés FAST
    function detectFAST(imageData, threshold = 30) {
      const { width, height, data } = imageData;
      const keypoints = [];
      
      for (let y = 3; y < height - 3; y++) {
        for (let x = 3; x < width - 3; x++) {
          const idx = (y * width + x) * 4;
          const centerValue = data[idx];
          
          const circle = [
            [0, -3], [1, -3], [2, -2], [3, -1],
            [3, 0], [3, 1], [2, 2], [1, 3],
            [0, 3], [-1, 3], [-2, 2], [-3, 1],
            [-3, 0], [-3, -1], [-2, -2], [-1, -3]
          ];
          
          let brighter = 0, darker = 0;
          for (const [dx, dy] of circle) {
            const px = x + dx, py = y + dy;
            if (px >= 0 && px < width && py >= 0 && py < height) {
              const pidx = (py * width + px) * 4;
              const val = data[pidx];
              
              if (val > centerValue + threshold) brighter++;
              if (val < centerValue - threshold) darker++;
            }
          }
          
          if (brighter >= 12 || darker >= 12) {
            keypoints.push({ x, y, response: Math.max(brighter, darker) });
          }
        }
      }
      
      return keypoints.sort((a, b) => b.response - a.response).slice(0, 1000);
    }

    // Descripteur de patch
    function computeDescriptor(imageData, kp, patchSize = 16) {
      const { width, height, data } = imageData;
      const descriptor = [];
      const half = Math.floor(patchSize / 2);
      
      for (let dy = -half; dy < half; dy++) {
        for (let dx = -half; dx < half; dx++) {
          const x = kp.x + dx, y = kp.y + dy;
          if (x >= 0 && x < width && y >= 0 && y < height) {
            const idx = (y * width + x) * 4;
            descriptor.push(data[idx]);
          } else {
            descriptor.push(0);
          }
        }
      }
      
      return descriptor;
    }

    // Matching avec ratio test
    function matchDescriptors(desc1, desc2, kp1, kp2) {
      const matches = [];
      
      for (let i = 0; i < Math.min(desc1.length, 500); i++) {
        let bestDist = Infinity, secondBest = Infinity, bestIdx = -1;
        
        for (let j = 0; j < Math.min(desc2.length, 500); j++) {
          let dist = 0;
          const minLen = Math.min(desc1[i].length, desc2[j].length);
          for (let k = 0; k < minLen; k++) {
            const diff = desc1[i][k] - desc2[j][k];
            dist += diff * diff;
          }
          
          if (dist < bestDist) {
            secondBest = bestDist;
            bestDist = dist;
            bestIdx = j;
          } else if (dist < secondBest) {
            secondBest = dist;
          }
        }
        
        if (bestDist < 0.6 * secondBest && bestIdx !== -1) {
          matches.push({
            p1: kp1[i],
            p2: kp2[bestIdx],
            distance: bestDist
          });
        }
      }
      
      return matches;
    }

    // Application homographie
    function applyHomography(H, x, y) {
      const w = H[2][0] * x + H[2][1] * y + H[2][2];
      if (Math.abs(w) < 0.0001) return [x, y];
      const xp = (H[0][0] * x + H[0][1] * y + H[0][2]) / w;
      const yp = (H[1][0] * x + H[1][1] * y + H[1][2]) / w;
      return [xp, yp];
    }

    // Estimation homographie DLT
    function estimateHomographyDLT(matches) {
      if (matches.length < 4) return null;
      
      // Normalisation points
      const pts1 = matches.map(m => [m.p1.x, m.p1.y]);
      const pts2 = matches.map(m => [m.p2.x, m.p2.y]);
      
      const mean1 = [
        pts1.reduce((s, p) => s + p[0], 0) / pts1.length,
        pts1.reduce((s, p) => s + p[1], 0) / pts1.length
      ];
      const mean2 = [
        pts2.reduce((s, p) => s + p[0], 0) / pts2.length,
        pts2.reduce((s, p) => s + p[1], 0) / pts2.length
      ];
      
      const scale1 = Math.sqrt(2) / Math.max(0.001, pts1.reduce((s, p) => {
        const dx = p[0] - mean1[0], dy = p[1] - mean1[1];
        return s + Math.sqrt(dx*dx + dy*dy);
      }, 0) / pts1.length);
      
      const scale2 = Math.sqrt(2) / Math.max(0.001, pts2.reduce((s, p) => {
        const dx = p[0] - mean2[0], dy = p[1] - mean2[1];
        return s + Math.sqrt(dx*dx + dy*dy);
      }, 0) / pts2.length);
      
      // Construction matrice A
      const A = [];
      for (let i = 0; i < matches.length; i++) {
        const x1 = (pts1[i][0] - mean1[0]) * scale1;
        const y1 = (pts1[i][1] - mean1[1]) * scale1;
        const x2 = (pts2[i][0] - mean2[0]) * scale2;
        const y2 = (pts2[i][1] - mean2[1]) * scale2;
        
        A.push([
          -x1, -y1, -1, 0, 0, 0, x2*x1, x2*y1, x2
        ]);
        A.push([
          0, 0, 0, -x1, -y1, -1, y2*x1, y2*y1, y2
        ]);
      }
      
      // SVD approximation
      const ATA = multiplyMatrixTranspose(A);
      const h = solveEigenVector(ATA);
      
      if (!h) return null;
      
      const Hn = [
        [h[0], h[1], h[2]],
        [h[3], h[4], h[5]],
        [h[6], h[7], h[8]]
      ];
      
      // Dénormalisation
      const T1inv = [
        [1/scale1, 0, mean1[0]],
        [0, 1/scale1, mean1[1]],
        [0, 0, 1]
      ];
      
      const T2 = [
        [scale2, 0, -mean2[0]*scale2],
        [0, scale2, -mean2[1]*scale2],
        [0, 0, 1]
      ];
      
      const H = multiplyMatrix3x3(multiplyMatrix3x3(T2, Hn), T1inv);
      
      return H;
    }

    function multiplyMatrixTranspose(A) {
      const n = A[0].length;
      const ATA = Array(n).fill(0).map(() => Array(n).fill(0));
      
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          let sum = 0;
          for (let k = 0; k < A.length; k++) {
            sum += A[k][i] * A[k][j];
          }
          ATA[i][j] = sum;
        }
      }
      
      return ATA;
    }

    function solveEigenVector(M) {
      let v = Array(9).fill(0);
      v[8] = 1;
      
      for (let iter = 0; iter < 100; iter++) {
        const Mv = Array(9).fill(0);
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            Mv[i] += M[i][j] * v[j];
          }
        }
        
        const norm = Math.sqrt(Mv.reduce((s, x) => s + x*x, 0));
        if (norm < 1e-10) break;
        
        for (let i = 0; i < 9; i++) {
          v[i] = Mv[i] / norm;
        }
      }
      
      return v;
    }

    function multiplyMatrix3x3(A, B) {
      const C = Array(3).fill(0).map(() => Array(3).fill(0));
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          for (let k = 0; k < 3; k++) {
            C[i][j] += A[i][k] * B[k][j];
          }
        }
      }
      return C;
    }

    function invertHomography(H) {
      const det = 
        H[0][0] * (H[1][1] * H[2][2] - H[1][2] * H[2][1]) -
        H[0][1] * (H[1][0] * H[2][2] - H[1][2] * H[2][0]) +
        H[0][2] * (H[1][0] * H[2][1] - H[1][1] * H[2][0]);
      
      if (Math.abs(det) < 1e-10) return null;
      
      const invDet = 1.0 / det;
      
      return [
        [
          (H[1][1] * H[2][2] - H[1][2] * H[2][1]) * invDet,
          (H[0][2] * H[2][1] - H[0][1] * H[2][2]) * invDet,
          (H[0][1] * H[1][2] - H[0][2] * H[1][1]) * invDet
        ],
        [
          (H[1][2] * H[2][0] - H[1][0] * H[2][2]) * invDet,
          (H[0][0] * H[2][2] - H[0][2] * H[2][0]) * invDet,
          (H[0][2] * H[1][0] - H[0][0] * H[1][2]) * invDet
        ],
        [
          (H[1][0] * H[2][1] - H[1][1] * H[2][0]) * invDet,
          (H[0][1] * H[2][0] - H[0][0] * H[2][1]) * invDet,
          (H[0][0] * H[1][1] - H[0][1] * H[1][0]) * invDet
        ]
      ];
    }

    // RANSAC
    function ransacHomography(matches, iterations = 500, threshold = 5) {
      if (matches.length < 4) return null;
      
      let bestH = null, bestInliers = [];
      
      for (let iter = 0; iter < iterations; iter++) {
        const sample = [];
        const indices = new Set();
        
        while (sample.length < 4) {
          const idx = Math.floor(Math.random() * matches.length);
          if (!indices.has(idx)) {
            sample.push(matches[idx]);
            indices.add(idx);
          }
        }
        
        const H = estimateHomographyDLT(sample);
        if (!H) continue;
        
        const inliers = [];
        for (const m of matches) {
          const [x2pred, y2pred] = applyHomography(H, m.p1.x, m.p1.y);
          const dx = x2pred - m.p2.x;
          const dy = y2pred - m.p2.y;
          const error = Math.sqrt(dx*dx + dy*dy);
          
          if (error < threshold) {
            inliers.push(m);
          }
        }
        
        if (inliers.length > bestInliers.length) {
          bestInliers = inliers;
          bestH = H;
        }
      }
      
      if (bestInliers.length >= 10) {
        return estimateHomographyDLT(bestInliers);
      }
      
      return bestH;
    }

    // ASSEMBLAGE PANORAMIQUE CORRECT
    async function assemblePanorama() {
      if (images.length < 2) {
        alert('Veuillez charger au moins 2 images');
        return;
      }

      assembleBtn.disabled = true;
      setProgress('Chargement des images...');

      try {
        const imgElements = await Promise.all(
          images.map(img => new Promise((resolve) => {
            const el = new Image();
            el.onload = () => resolve(el);
            el.src = img.url;
          }))
        );

        setProgress('Détection des points clés FAST...');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const features = imgElements.map((img, idx) => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          const imageData = ctx.getImageData(0, 0, img.width, img.height);
          
          const keypoints = detectFAST(imageData);
          const descriptors = keypoints.map(kp => computeDescriptor(imageData, kp));
          
          setProgress(`Image ${idx + 1}: ${keypoints.length} points clés détectés`);
          
          return { imageData, keypoints, descriptors, img };
        });

        // IMAGE CENTRALE = RÉFÉRENCE
        const refIdx = Math.floor(features.length / 2);
        setProgress(`Image de référence: #${refIdx + 1}`);

        // Calculer homographies vers la référence
        const homographies = Array(features.length).fill(null);
        homographies[refIdx] = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // Identité pour la référence

        let matchInfo = [];

        // Gauche vers référence (composition)
        for (let i = refIdx - 1; i >= 0; i--) {
          setProgress(`Calcul homographie image ${i + 1} → référence...`);
          
          const matches = matchDescriptors(
            features[i].descriptors,
            features[i + 1].descriptors,
            features[i].keypoints,
            features[i + 1].keypoints
          );
          
          matchInfo.push(`${i + 1}→${i + 2}: ${matches.length} corresp`);
          
          if (matches.length >= 10) {
            const H_i_to_iplus1 = ransacHomography(matches);
            if (H_i_to_iplus1 && homographies[i + 1]) {
              // Composer: H_i_to_ref = H_iplus1_to_ref * H_i_to_iplus1
              homographies[i] = multiplyMatrix3x3(homographies[i + 1], H_i_to_iplus1);
            }
          }
        }

        // Droite vers référence (composition)
        for (let i = refIdx + 1; i < features.length; i++) {
          setProgress(`Calcul homographie image ${i + 1} → référence...`);
