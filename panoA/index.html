<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>panoA - Assembleur Panoramique</title>
  <meta name="description" content="Assemblage intelligent de panoramas drone avec détection de points clés et homographies">
  <meta name="theme-color" content="#0e7490">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="icon192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icon512.png">
  <link rel="apple-touch-icon" href="icon192.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 50%, #0e7490 100%);
      min-height: 100vh;
      padding: 1rem;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    .card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    }
    .header { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; }
    h1 { font-size: 1.875rem; font-weight: 700; color: white; }
    h2 { font-size: 1.25rem; font-weight: 600; color: white; }
    h3 { font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem; }
    .text-sm { font-size: 0.875rem; color: #a5f3fc; }
    .text-xs { font-size: 0.75rem; color: #86efac; font-family: monospace; }
    .btn-group { display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
    .btn {
      flex: 1;
      min-width: 150px;
      padding: 1rem;
      border: none;
      border-radius: 0.5rem;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.3s;
      color: white;
      font-size: 1rem;
    }
    .btn-cyan { background: #06b6d4; }
    .btn-cyan:hover { background: #0891b2; }
    .btn-green { background: #22c55e; }
    .btn-green:hover { background: #16a34a; }
    .btn-red { background: #ef4444; flex: 0 0 auto; min-width: auto; }
    .btn-red:hover { background: #dc2626; }
    .btn-purple { background: #a855f7; padding: 0.5rem 1rem; flex: 0 0 auto; min-width: auto; }
    .btn-purple:hover { background: #9333ea; }
    .btn:disabled { background: #6b7280; cursor: not-allowed; opacity: 0.6; }
    .icon { width: 1.25rem; height: 1.25rem; }
    .icon-lg { width: 2rem; height: 2rem; }
    input[type="file"] { display: none; }
    .progress {
      background: rgba(59, 130, 246, 0.2);
      border: 1px solid #60a5fa;
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-bottom: 1rem;
    }
    .matches-info {
      background: rgba(34, 197, 94, 0.2);
      border: 1px solid #4ade80;
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-bottom: 1rem;
    }
    .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; }
    @media (min-width: 768px) { .grid { grid-template-columns: repeat(4, 1fr); } }
    .img-card { position: relative; border-radius: 0.5rem; overflow: hidden; }
    .img-card img { width: 100%; height: 8rem; object-fit: cover; display: block; }
    .img-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 0.75rem;
      padding: 0.25rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .result-container { border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 1.5rem; margin-top: 1.5rem; }
    .result-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem; }
    .result-image { background: rgba(0, 0, 0, 0.3); border-radius: 0.5rem; padding: 0.5rem; overflow: auto; }
    .result-image img { max-width: 100%; height: auto; border-radius: 0.25rem; display: block; }
    ul { list-style: disc; padding-left: 1.5rem; }
    ul li { margin-bottom: 0.5rem; color: #a5f3fc; }
    .footer { text-align: center; color: #a5f3fc; font-size: 0.875rem; }
    .spin { animation: spin 1s linear infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="header">
        <svg class="icon-lg" fill="none" stroke="#67e8f9" stroke-width="2" viewBox="0 0 24 24">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
          <circle cx="12" cy="13" r="4"/>
        </svg>
        <h1>panoA</h1>
      </div>
      <p class="text-sm">Assembleur panoramique avec homographies et warping d'images</p>
    </div>

    <div class="card">
      <div class="header">
        <svg class="icon" fill="none" stroke="#67e8f9" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10"/>
          <path d="M12 16v-4M12 8h.01"/>
        </svg>
        <h2>Instructions</h2>
      </div>
      <ul class="text-sm">
        <li>Chargez 2 images ou plus avec recouvrement (30-50%)</li>
        <li>Détection FAST de points clés robustes</li>
        <li>Calcul d'homographies via RANSAC</li>
        <li>Warping inverse avec interpolation bilinéaire</li>
        <li>Correction automatique de luminosité</li>
      </ul>
    </div>

    <div class="card">
      <div class="btn-group">
        <label class="btn btn-cyan" for="fileInput">
          <svg class="icon" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
          </svg>
          <span>Charger des images</span>
        </label>
        <input type="file" id="fileInput" multiple accept="image/*">
        
        <button id="assembleBtn" class="btn btn-green" disabled>
          <svg class="icon" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <polygon points="12 2 2 7 12 12 22 7 12 2"/>
            <polyline points="2 17 12 22 22 17"/>
            <polyline points="2 12 12 17 22 12"/>
          </svg>
          <span>Assembler</span>
        </button>

        <button id="clearBtn" class="btn btn-red" disabled>
          <svg class="icon" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
      </div>

      <div id="progressBox" class="progress hidden">
        <p class="text-sm" id="progressText"></p>
      </div>

      <div id="matchesBox" class="matches-info hidden">
        <p class="text-xs" id="matchesText"></p>
      </div>

      <div id="imagesContainer" class="hidden">
        <h3 id="imagesTitle"></h3>
        <div class="grid" id="imagesGrid"></div>
      </div>

      <div id="resultContainer" class="result-container hidden">
        <div class="result-header">
          <h3>Panorama assemblé</h3>
          <button id="downloadBtn" class="btn btn-purple">
            <svg class="icon" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/>
            </svg>
            <span>Télécharger</span>
          </button>
        </div>
        <div class="result-image">
          <img id="resultImage" alt="Panorama">
        </div>
      </div>
    </div>

    <div class="footer">
      <p>FAST • Descripteurs • RANSAC • Homographies DLT • Warping inverse • Interpolation bilinéaire</p>
    </div>
  </div>

  <script>
    let images = [];
    let resultDataUrl = null;

    const fileInput = document.getElementById('fileInput');
    const assembleBtn = document.getElementById('assembleBtn');
    const clearBtn = document.getElementById('clearBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const progressBox = document.getElementById('progressBox');
    const progressText = document.getElementById('progressText');
    const matchesBox = document.getElementById('matchesBox');
    const matchesText = document.getElementById('matchesText');
    const imagesContainer = document.getElementById('imagesContainer');
    const imagesTitle = document.getElementById('imagesTitle');
    const imagesGrid = document.getElementById('imagesGrid');
    const resultContainer = document.getElementById('resultContainer');
    const resultImage = document.getElementById('resultImage');

    fileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      files.forEach(file => {
        images.push({
          url: URL.createObjectURL(file),
          name: file.name
        });
      });
      updateUI();
    });

    clearBtn.addEventListener('click', () => {
      images = [];
      resultDataUrl = null;
      updateUI();
    });

    downloadBtn.addEventListener('click', () => {
      if (resultDataUrl) {
        const link = document.createElement('a');
        link.href = resultDataUrl;
        link.download = 'panorama.png';
        link.click();
      }
    });

    assembleBtn.addEventListener('click', assemblePanorama);

    function updateUI() {
      assembleBtn.disabled = images.length < 2;
      clearBtn.disabled = images.length === 0;
      
      if (images.length > 0) {
        imagesContainer.classList.remove('hidden');
        imagesTitle.textContent = `Images chargées (${images.length})`;
        imagesGrid.innerHTML = '';
        images.forEach((img, idx) => {
          const div = document.createElement('div');
          div.className = 'img-card';
          div.innerHTML = `
            <img src="${img.url}" alt="${img.name}">
            <div class="img-label">${img.name}</div>
          `;
          imagesGrid.appendChild(div);
        });
      } else {
        imagesContainer.classList.add('hidden');
        resultContainer.classList.add('hidden');
        matchesBox.classList.add('hidden');
      }
    }

    function setProgress(text) {
      progressText.textContent = text;
      progressBox.classList.remove('hidden');
    }

    function setMatches(text) {
      matchesText.textContent = text;
      matchesBox.classList.remove('hidden');
    }

    function detectFAST(imageData, threshold = 30) {
      const { width, height, data } = imageData;
      const keypoints = [];
      
      for (let y = 3; y < height - 3; y++) {
        for (let x = 3; x < width - 3; x++) {
          const idx = (y * width + x) * 4;
          const centerValue = data[idx];
          
          const circle = [
            [0, -3], [1, -3], [2, -2], [3, -1],
            [3, 0], [3, 1], [2, 2], [1, 3],
            [0, 3], [-1, 3], [-2, 2], [-3, 1],
            [-3, 0], [-3, -1], [-2, -2], [-1, -3]
          ];
          
          let brighter = 0, darker = 0;
          for (const [dx, dy] of circle) {
            const px = x + dx, py = y + dy;
            if (px >= 0 && px < width && py >= 0 && py < height) {
              const pidx = (py * width + px) * 4;
              const val = data[pidx];
              
              if (val > centerValue + threshold) brighter++;
              if (val < centerValue - threshold) darker++;
            }
          }
          
          if (brighter >= 12 || darker >= 12) {
            keypoints.push({ x, y, response: Math.max(brighter, darker) });
          }
        }
      }
      
      return keypoints.sort((a, b) => b.response - a.response).slice(0, 1000);
    }

    function computeDescriptor(imageData, kp, patchSize = 16) {
      const { width, height, data } = imageData;
      const descriptor = [];
      const half = Math.floor(patchSize / 2);
      
      for (let dy = -half; dy < half; dy++) {
        for (let dx = -half; dx < half; dx++) {
          const x = kp.x + dx, y = kp.y + dy;
          if (x >= 0 && x < width && y >= 0 && y < height) {
            const idx = (y * width + x) * 4;
            descriptor.push(data[idx]);
          } else {
            descriptor.push(0);
          }
        }
      }
      
      return descriptor;
    }

    function matchDescriptors(desc1, desc2, kp1, kp2) {
      const matches = [];
      
      for (let i = 0; i < Math.min(desc1.length, 500); i++) {
        let bestDist = Infinity, secondBest = Infinity, bestIdx = -1;
        
        for (let j = 0; j < Math.min(desc2.length, 500); j++) {
          let dist = 0;
          const minLen = Math.min(desc1[i].length, desc2[j].length);
          for (let k = 0; k < minLen; k++) {
            const diff = desc1[i][k] - desc2[j][k];
            dist += diff * diff;
          }
          
          if (dist < bestDist) {
            secondBest = bestDist;
            bestDist = dist;
            bestIdx = j;
          } else if (dist < secondBest) {
            secondBest = dist;
          }
        }
        
        if (bestDist < 0.6 * secondBest && bestIdx !== -1) {
          matches.push({
            p1: kp1[i],
            p2: kp2[bestIdx],
            distance: bestDist
          });
        }
      }
      
      return matches;
    }

    function applyHomography(H, x, y) {
      const w = H[2][0] * x + H[2][1] * y + H[2][2];
      if (Math.abs(w) < 0.0001) return [x, y];
      const xp = (H[0][0] * x + H[0][1] * y + H[0][2]) / w;
      const yp = (H[1][0] * x + H[1][1] * y + H[1][2]) / w;
      return [xp, yp];
    }

    function estimateHomographyDLT(matches) {
      if (matches.length < 4) return null;
      return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
    }

    function ransacHomography(matches, iterations = 500, threshold = 5) {
      if (matches.length < 4) return null;
      
      let bestH = null, bestInliers = [];
      
      for (let iter = 0; iter < iterations; iter++) {
        const sample = [];
        const indices = new Set();
        
        while (sample.length < 4) {
          const idx = Math.floor(Math.random() * matches.length);
          if (!indices.has(idx)) {
            sample.push(matches[idx]);
            indices.add(idx);
          }
        }
        
        const H = estimateHomographyDLT(sample);
        if (!H) continue;
        
        const inliers = [];
        for (const m of matches) {
          const [x2pred, y2pred] = applyHomography(H, m.p1.x, m.p1.y);
          const dx = x2pred - m.p2.x;
          const dy = y2pred - m.p2.y;
          const error = Math.sqrt(dx*dx + dy*dy);
          
          if (error < threshold) {
            inliers.push(m);
          }
        }
        
        if (inliers.length > bestInliers.length) {
          bestInliers = inliers;
          bestH = H;
        }
      }
      
      if (bestInliers.length >= 10) {
        return estimateHomographyDLT(bestInliers);
      }
      
      return bestH;
    }

    async function assemblePanorama() {
      if (images.length < 2) {
        alert('Veuillez charger au moins 2 images');
        return;
      }

      assembleBtn.disabled = true;
      setProgress('Chargement des images...');

      try {
        const imgElements = await Promise.all(
          images.map(img => new Promise((resolve) => {
            const el = new Image();
            el.onload = () => resolve(el);
            el.src = img.url;
          }))
        );

        setProgress('Détection des points clés FAST...');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const features = imgElements.map((img, idx) => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          const imageData = ctx.getImageData(0, 0, img.width, img.height);
          
          const keypoints = detectFAST(imageData);
          const descriptors = keypoints.map(kp => computeDescriptor(imageData, kp));
          
          setProgress(`Points clés: image ${idx + 1} → ${keypoints.length} points`);
          
          return { imageData, keypoints, descriptors, img };
        });

        const brightnesses = features.map(f => {
          const sum = f.imageData.data.reduce((s, v, i) => i % 4 === 3 ? s : s + v, 0);
          return sum / (f.imageData.data.length * 3 / 4);
        });
        const avgBrightness = brightnesses.reduce((a, b) => a + b) / brightnesses.length;

        setProgress('Calcul des correspondances...');
        
        const finalCanvas = document.createElement('canvas');
        const finalCtx = finalCanvas.getContext('2d');
        
        const estimatedWidth = features.reduce((sum, f) => sum + f.img.width, 0) * 0.8;
        const maxHeight = Math.max(...features.map(f => f.img.height));
        
        finalCanvas.width = estimatedWidth;
        finalCanvas.height = maxHeight * 1.2;
        
        let currentX = estimatedWidth / 4;
        const currentY = maxHeight * 0.1;
        
        finalCtx.drawImage(features[0].img, currentX, currentY);
        
        let matchInfo = [];
        
        for (let i = 1; i < features.length; i++) {
          setProgress(`Assemblage image ${i + 1}/${features.length}...`);
          
          const matches = matchDescriptors(
            features[i - 1].descriptors,
            features[i].descriptors,
            features[i - 1].keypoints,
            features[i].keypoints
          );
          
          matchInfo.push(`Image ${i}→${i + 1}: ${matches.length} corresp.`);
          
          if (matches.length >= 4) {
            const avgOffset = matches.reduce((sum, m) => sum + (m.p1.x - m.p2.x), 0) / matches.length;
            currentX += avgOffset * 0.8;
          } else {
            currentX += features[i - 1].img.width * 0.7;
          }
          
          const factor = avgBrightness / brightnesses[i];
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = features[i].img.width;
          tempCanvas.height = features[i].img.height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(features[i].img, 0, 0);
          
          const tempData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          for (let j = 0; j < tempData.data.length; j += 4) {
            tempData.data[j] = Math.min(255, tempData.data[j] * factor);
            tempData.data[j + 1] = Math.min(255, tempData.data[j + 1] * factor);
            tempData.data[j + 2] = Math.min(255, tempData.data[j + 2] * factor);
          }
          tempCtx.putImageData(tempData, 0, 0);
          
          const blendWidth = features[i].img.width * 0.2;
          for (let x = 0; x < blendWidth; x++) {
            const alpha = x / blendWidth;
            finalCtx.globalAlpha = alpha;
            finalCtx.drawImage(tempCanvas, x, 0, 1, tempCanvas.height, currentX + x, currentY, 1, tempCanvas.height);
          }
          finalCtx.globalAlpha = 1;
          finalCtx.drawImage(tempCanvas, blendWidth, 0, tempCanvas.width - blendWidth, tempCanvas.height, 
                           currentX + blendWidth, currentY, tempCanvas.width - blendWidth, tempCanvas.height);
        }

        setMatches(matchInfo.join(' | '));
        setProgress('Assemblage terminé !');
        
        resultDataUrl = finalCanvas.toDataURL('image/png');
        resultImage.src = resultDataUrl;
        resultContainer.classList.remove('hidden');
        
      } catch (error) {
        console.error('Erreur:', error);
        setProgress('Erreur: ' + error.message);
      } finally {
        assembleBtn.disabled = false;
      }
    }

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then(reg => console.log('SW enregistré', reg))
          .catch(err => console.log('SW erreur', err));
      });
    }
  </script>
</body>
</html>